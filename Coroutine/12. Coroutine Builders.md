Kotlin Coroutines의 launch, runBlocking, async는 모두 **코루틴 빌더(Coroutine Builder)**로 사용되며, 코루틴을 생성하고 실행하는 데 사용됩니다. 이 세 가지는 코루틴의 **실행 방식**, **반환 값**, 그리고 **사용 목적**에서 차이가 있습니다.

## **1. 코루틴 빌더의 개요**

### **1.1 launch**

• **특징**:
	• **Job** 객체를 반환.
	• 결과를 반환하지 않는 **작업 실행**을 위해 사용.
	• **비동기 실행**이 가능하며, 호출한 스레드와 독립적으로 실행됨.

• **사용 목적**:
	• 결과를 신경 쓰지 않는 **비동기 작업** 실행.
	• 주로 **Fire-and-forget** 작업(결과를 기다리지 않는 작업)에 적합.

**예제:**
  
```kotlin
fun main() = runBlocking {
    launch {
        println("launch: 실행 중")
    }
    println("main: 완료")
}
```

  

**출력**:

  

main: 완료

launch: 실행 중

  

• launch 블록은 **비동기**로 실행되며, 메인 함수의 코드 실행을 차단하지 않습니다.

  

### **1.2 runBlocking**

• **특징**:

• **현재 스레드를 차단**(blocking)하여 코루틴이 완료될 때까지 대기.

• 반환값이 있는 경우 **최종 결과 반환**.

• 주로 **테스트 또는 메인 함수**에서 코루틴 실행을 시작할 때 사용.

• **사용 목적**:

• 코루틴 환경이 없는 곳에서 **코루틴을 동기적으로 실행**.

• 예: 메인 함수나 테스트 코드에서 코루틴 실행.

  

**예제:**

  

fun main() = runBlocking {

    println("runBlocking: 실행 중")

}

  

**출력**:

  

runBlocking: 실행 중


• runBlocking은 **현재 스레드**(여기서는 main)를 차단하고 내부 코루틴이 완료될 때까지 대기합니다.

### **1.3 async**

• **특징**:
	• **Deferred** 객체를 반환.
	• **결과값을 반환**하기 위한 비동기 작업에 사용.
	• **await**를 호출하여 결과를 비동기적으로 받을 수 있음.

• **사용 목적**:
	• 결과값이 필요한 **비동기 계산 작업**.
	• 여러 작업을 병렬로 실행하고 결과를 결합할 때 적합.

  

**예제:**

```kotlin
fun main() = runBlocking {
    launch {
        println("launch: 실행 중")
    }
    println("main: 완료")
}
```

  

**출력**:

  

async: 계산 중

결과: 42

  

• async는 **결과값**(여기서는 42)을 반환하며, await를 사용해 결과를 받을 때까지 대기합니다.

  

**2. 주요 차이점**

| **특징** | **launch**     | **runBlocking** | **async**        |
| ------ | -------------- | --------------- | ---------------- |
| 반환 타입  | Job            | 최종 결과           | Deferred<T>      |
| 결과값 반환 | 없음             | 있음              | 있음               |
| 실행 방식  | 비동기            | 동기(현재 스레드 차단)   | 비동기              |
| 사용 목적  | 결과가 필요 없는 작업   | 테스트/메인 함수에서 코루틴 | 결과가 필요한 작업       |
| 예제 용도  | 로그 기록, 파일 처리 등 | 메인 함수의 시작점      | 비동기 계산, 병렬 작업 처리 |

  

**3. 함께 사용하는 예제**

  

### **3.1 launch와 async**

• 비동기 작업(launch)과 결과값이 필요한 비동기 작업(async)을 함께 사용하는 경우:

  

fun main() = runBlocking {

    val job = launch {

        println("launch: 비동기 작업 실행 중")

    }

    val deferred = async {

        println("async: 계산 작업 실행 중")

        42

    }

    job.join() _// launch 작업 완료 대기_

    println("async 결과: ${deferred.await()}") _// async 결과 대기_

}

  

**출력**:

  

launch: 비동기 작업 실행 중

async: 계산 작업 실행 중

async 결과: 42

  

• launch는 결과값 없이 작업을 실행하며, job.join()으로 작업이 완료되길 기다립니다.

• async는 결과값을 반환하며, await로 결과를 대기합니다.

  

### **3.2 runBlocking으로 코루틴 실행**

• runBlocking은 **코루틴 환경이 없는 곳**에서 코루틴을 실행하는 데 사용됩니다.

  

fun main() {

    runBlocking {

        launch {

            println("runBlocking + launch: 비동기 작업 실행")

        }

        println("runBlocking: 동기 작업 실행")

    }

    println("main: 완료")

}

  

**출력**:

  

runBlocking: 동기 작업 실행

runBlocking + launch: 비동기 작업 실행

main: 완료

  

• runBlocking 내부에서 launch를 실행하면, runBlocking은 launch 작업이 완료될 때까지 대기합니다.

  

**4. 언제 무엇을 사용할까?**

  

### **4.1 launch**

• 결과를 신경 쓰지 않는 작업:

• 예: 로그 작성, 알림 전송, 파일 다운로드.

  

### **4.2 runBlocking**

• 코루틴 환경이 없는 곳에서 동기적으로 실행해야 할 때:

• 예: 메인 함수, 테스트 코드.

  

### **4.3 async**

• 결과값이 필요한 비동기 계산 작업:

• 예: 병렬로 데이터 처리 후 결과를 결합해야 하는 경우.

  

**5. 결론**

• launch: 결과가 필요 없는 비동기 작업 실행.

• runBlocking: 현재 스레드를 차단하며, 코루틴 환경이 없는 곳에서 사용.

• async: 비동기 작업에서 결과를 반환받기 위해 사용.

  

이 세 가지는 각각 다른 용도에 적합하며, 적절히 조합하여 사용하면 효율적인 코루틴 기반 비동기 작업 처리가 가능합니다.