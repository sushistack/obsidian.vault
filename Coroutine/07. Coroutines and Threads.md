

Kotlin에서 코루틴과 스레드는 모두 동시성 처리를 위해 사용될 수 있습니다. 하지만 코루틴은 효율성과 경량성 면에서 스레드와 본질적으로 다릅니다. 아래에서는 코루틴과 스레드를 비교하며, 왜 코루틴이 현대 애플리케이션 개발에서 주목받는지 설명합니다.


## **1. 코루틴과 스레드: 기본 동작 비교**

### **1.1 코루틴으로 동시성 구현**

  

코루틴은 launch를 통해 새로운 작업을 시작합니다. 두 개의 코루틴을 실행하면 작업이 동시에 처리되고 종료됩니다. 모든 작업은 동일한 스레드(예: 메인 스레드)에서 실행되며, 추가적인 스레드 전환 없이도 동시성을 구현할 수 있습니다.

  
```kotlin
fun main() = runBlocking {
    launch {
        println("코루틴 1 실행 중")
    }
    launch {
        println("코루틴 2 실행 중")
    }
    println("모든 작업 완료")
}
```

출력 예시:

```
코루틴 1 실행 중
코루틴 2 실행 중
모든 작업 완료
```

### **1.2 스레드로 동시성 구현**

동일한 작업을 스레드로 구현할 수도 있습니다. Kotlin의 thread 함수를 사용해 두 개의 스레드를 생성하고 실행하면 비슷한 결과를 얻을 수 있습니다. 단, 스레드가 작업을 완료하기 전에 메인 스레드가 종료되지 않도록 Thread.sleep을 추가해야 합니다.

  
```kotlin
fun main() {
    thread {
        println("스레드 1 실행 중")
    }
    thread {
        println("스레드 2 실행 중")
    }
    Thread.sleep(1000)
    println("모든 작업 완료")
}
```

출력은 비슷하지만, 스레드는 작업마다 새로운 스레드를 생성하며, 이는 리소스를 더 많이 소모합니다.

## **2. 코루틴의 동작 원리**

### **2.1 코루틴은 동일한 스레드에서 실행**

코루틴은 새로운 스레드를 생성하지 않고도 동시 작업을 처리합니다. 동일한 작업을 코루틴으로 실행하고 각 코루틴의 실행 스레드를 출력하면, 모든 코루틴이 동일한 스레드에서 실행된다는 것을 확인할 수 있습니다.

```kotlin
suspend fun printThreadInfo(task: String) {
    println("$task 실행 중 - 스레드: ${Thread.currentThread().name}")
}

fun main() = runBlocking {
    launch { printThreadInfo("코루틴 1") }
    launch { printThreadInfo("코루틴 2") }
}
```

출력 예시:
  
```
코루틴 1 실행 중 - 스레드: main
코루틴 2 실행 중 - 스레드: main
```

이는 코루틴이 JVM의 스레드 풀과 협력하여 경량 동시성을 구현하기 때문입니다.

or

```kotlin
fun main() = runBlocking {  
    println("main starts")  
    joinAll(  
        async { threadInfoCoroutine(1, 500) },  
        async { threadInfoCoroutine(2, 300) }  
    )  
    println("main ends")  
}  
  
suspend fun threadInfoCoroutine(number: Int, delay: Long) {  
    println("Coroutine $number starts work on ${Thread.currentThread().name}")  
    delay(delay)  
    println("Coroutine $number has finished on ${Thread.currentThread().name}")  
}
```

• runBlocking 블록은 호출된 스레드(여기서는 main)를 사용합니다.
• 여러 launch 코루틴이 실행되더라도, 메인 스레드는 **코루틴 실행 시점에서 활성 코루틴을 실행**하고, 필요할 경우 다른 코루틴으로 전환합니다.
• 이는 스레드가 **각 코루틴을 협력적으로 번갈아가며 실행**한다는 의미입니다.

## **3. 경량성 테스트: 100만 작업 실행** (Thread Pool)


**3.1 코루틴으로 100만 작업 실행**

코루틴은 수많은 작업을 효율적으로 실행할 수 있습니다. 아래 예제에서는 100만 개의 코루틴을 생성하여 각 코루틴이 5초 지연 후 점(.)을 출력하도록 설정했습니다.

  
```kotlin
fun main() = runBlocking {
    repeat(1_000_000) {
        launch {
            delay(5000L)
            print(".")
        }
    }
}
```
  

결과적으로, **100만 개의 코루틴**이 문제없이 실행되며 모든 작업이 성공적으로 처리됩니다. 코루틴은 새로운 스레드를 생성하지 않기 때문에 리소스를 효율적으로 활용합니다.

### **3.2 스레드로 100만 작업 실행**

동일한 작업을 스레드로 구현해보면, 시스템의 한계를 금방 확인할 수 있습니다.

```kotlin
fun main() {
    repeat(1_000_000) {
        thread {
            Thread.sleep(5000L)
            print(".")
        }
    }
}
```

실행 결과:

```
Java.lang.OutOfMemoryError: Unable to create new native thread
```

**메모리 부족 오류**가 발생하며, 시스템이 더 이상 스레드를 생성할 수 없게 됩니다. 이는 스레드가 각 작업마다 약 1MB의 메모리를 요구하기 때문입니다.


## **4. 코루틴의 장점**

### **4.1 메모리 사용량 감소**

코루틴은 스레드보다 훨씬 적은 메모리를 소비합니다. 수많은 코루틴을 생성하더라도 새로운 스레드를 생성하지 않으므로, 시스템 리소스를 효율적으로 활용할 수 있습니다.

### **4.2 전환 비용 절감**

스레드 전환은 운영체제 수준에서 이루어지며, 상당한 비용이 소모됩니다. 반면, 코루틴은 JVM 내부에서 관리되며, 전환 비용이 매우 낮습니다.

### **4.3 비동기 작업 최적화**

코루틴은 비동기 작업(예: 네트워크 요청, 파일 입출력)을 처리하는 데 최적화되어 있습니다. **suspend 함수**를 통해 비동기 작업을 간결하고 안전하게 구현할 수 있습니다.

## **5. 스레드와 코루틴의 한계**

### **5.1 스레드의 단점**

• **메모리 소모**: 각 스레드마다 약 1MB의 메모리가 필요.
• **전환 비용**: 스레드 간 전환은 운영체제에서 처리되며, 비용이 크다.
• **확장성 부족**: 많은 스레드를 생성할 경우 시스템 리소스 한계에 도달.

### **5.2 코루틴의 단점**

• **학습 곡선**: 코루틴의 개념(suspend 함수, 스코프 등)을 이해해야 함.
• **JVM 환경 의존성**: Kotlin 코루틴은 JVM 기반에서 최적화되어 있으며, 다른 플랫폼에서는 동일한 성능을 보장하지 않을 수 있음.

## **6. 결론: 코루틴을 언제 사용할까?**

코루틴은 메모리 사용량이 적고, 대규모 동시성 작업을 처리하기에 적합하며, 특히 비동기 작업을 간결하게 작성할 수 있다는 장점이 있습니다. 다음과 같은 경우 코루틴을 사용하는 것이 권장됩니다:

• **비동기 작업**: 네트워크 요청, 파일 입출력, 데이터베이스 작업 등.
• **대규모 동시성 작업**: 수백만 개의 작업을 처리해야 하는 경우.
• **리소스 제한 환경**: 메모리와 CPU 사용을 최소화해야 하는 애플리케이션.

반면, 간단한 동시성 작업이나 운영체제 수준의 스레드 관리가 필요한 경우에는 기존 스레드를 사용하는 것이 적합할 수 있습니다.

결론적으로, 코루틴은 현대 애플리케이션 개발에서 강력한 도구로, 적절히 사용하면 효율성과 확장성을 극대화할 수 있습니다. 하지만 적절한 사용법과 한계를 이해하고 적용해야 최상의 결과를 얻을 수 있습니다.



## Thread Pool로 해결할 수 없는 문제*

Thread Pool을 사용해도 해결되지 않는 몇 가지 문제가 있습니다:

### 1. **스택 메모리 제한**

• 각 스레드는 고정 크기의 스택 메모리를 사용하므로, 스레드 풀 크기를 초과하는 작업을 처리하기 어렵습니다.
• 코루틴은 스택 메모리를 공유하며, 필요할 때만 메모리를 동적으로 할당합니다.

### 2. **코드 복잡성**

• Thread Pool을 사용한 동시성 처리는 종종 복잡한 동기화 및 오류 처리 메커니즘이 필요합니다.
• 코루틴은 launch, async 등 간단한 빌더를 제공하며, 예외 처리도 코루틴 스코프 내에서 쉽게 관리할 수 있습니다.

### 3. **확장성**

• Thread Pool은 스레드 풀 크기에 따라 확장성에 한계가 있습니다.
• 코루틴은 적은 수의 스레드로도 대규모 작업을 처리할 수 있어, 확장성이 뛰어납니다.