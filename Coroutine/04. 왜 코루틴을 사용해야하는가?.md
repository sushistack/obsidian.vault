콜백, RxJava, 그리고 코루틴이라는 세 가지 인기 있는 비동기 프로그래밍 접근 방식을 사용하여 유스케이스를 구현한 지금, 이번 강의에서는 세 가지 솔루션을 비교하고 왜 현재 안드로이드에서 코루틴이 가장 좋은 접근 방식이라고 생각하는지 그 이유를 말씀드리고자 합니다.

내일 새로운 안드로이드 애플리케이션을 시작한다고 상상해보세요. 애플리케이션이 단순한 Hello World 앱이 아니라 복잡한 로직을 가진 더 정교한 앱일 것입니다. 여러 개발자가 함께 작업할 것입니다.

어떤 비동기 프로그래밍 접근 방식을 사용해야 할까요? 어떻게 잘 고려된 결정을 내릴 수 있을까요?

음, 저는 다음과 같은 질문을 스스로에게 하는 것이 합리적이라고 생각합니다.

전문 소프트웨어 개발자가 특정 접근 방식이나 솔루션을 비교, 평가하고 최종적으로 선택하는 가장 좋은 방법은 무엇일까요?

이번 강의에서는 이 질문에 대한 제 답변을 드리고자 합니다.

콜백이 콜백 헬을 초래할 수 있고, RxJava가 배우고 이해하기 어렵기 때문에 나쁘다는 단순한 결론은 충분하지 않다고 생각합니다. 우리는 더 깊이 있는 이유를 가지고 왜 특정 방식으로 일을 하고 싶은지에 대해 더 많은 시간과 고려를 기울여야 한다고 생각합니다. 비동기 프로그래밍 방식을 선택하는 것은 사소한 문제가 아니라 애플리케이션에 매우 중요한 사항입니다.

개인적으로 소프트웨어 개발에서 결정을 내릴 때 잠재적인 솔루션이 반드시 가져야 할 가장 중요한 품질은 유지보수성이라고 생각합니다. 제가 생각하기에 가장 좋은 솔루션은 가장 유지보수가 용이한 솔루션입니다. 하지만 아마도 지금 자신에게 '유지보수성'이 정확히 무엇을 의미하는지 물어보고 있을 것입니다.

유지보수성에 대한 다양한 정의가 있지만, 제 의견으로는 다음과 같습니다.

소프트웨어 프로젝트의 유지보수성이 높다는 것은 첫째, 코드 변경에 걸리는 시간이 적고, 둘째, 이 변경이 새로운 버그를 유발할 위험이 낮다는 것을 의미합니다.

하지만 이 정의만으로는 아직 도움이 되지 않습니다. 이를 더 세분화해야 합니다.

첫째, 코드 변경에 걸리는 시간에 대해 자세히 살펴보겠습니다. 코드 변경이 필요한 이유는 버그 수정, 애플리케이션의 동작 수정 또는 확장 등 여러 가지가 있습니다. 어떤 이유든, 항상 먼저 코드를 이해해야 변경을 할 수 있습니다. 따라서 코드 변경에 걸리는 시간은 첫째, 코드를 이해하는 데 필요한 시간에 달려 있습니다. 이는 가독성 또는 이해 가능성에 의존합니다.

둘째, 실제 코드 변경을 하는 데 필요한 시간입니다. 이는 코드가 얼마나 유연한지에 달려 있습니다. 코드의 가독성이 높아 코드를 이해하는 데 걸리는 시간이 짧을수록, 실제 코드를 변경하는 데 필요한 시간도 짧아집니다. 제가 개인적으로 생각하는 유연성이란, 코드를 쉽게 변경하거나 확장할 수 있는 속성을 의미합니다.

따라서 우리는 비동기 코드가 좋은 유지보수성을 가지기 위해 필요한 첫 두 가지 기준, 즉 높은 이해 가능성과 높은 유연성을 식별했습니다.

이제 정의의 다른 부분을 살펴보겠습니다. 코드의 유지보수성이 높다는 것은 코드 변경이 새로운 버그를 유발할 위험이 낮다는 것을 의미합니다. 이 위험은 첫째, 구성 요소 간의 결합 수준에 달려 있습니다. 높은 결합도를 가진 스파게티 코드에서는 새로운 결함을 도입할 위험이 잘 분리된 프로젝트보다 훨씬 높습니다. 따라서 좋은 아키텍처를 갖추면 새로운 결함을 도입할 가능성을 줄일 수 있습니다.

그러나 비동기 프로그래밍 방식을 선택하는 것은 애플리케이션의 아키텍처나 결합 수준에 큰 영향을 미치지 않습니다. 따라서 이 측면은 우리의 의사 결정 과정에서 크게 관련이 없습니다.

둘째, 코드 변경이 새로운 버그를 유발할 위험은 프로젝트에 얼마나 많은 테스트 커버리지가 있는지에 따라 달라집니다. 만약 우리의 앱이 견고한 테스트 전략을 따르고 있고 많은 테스트가 준비되어 있다면, 버그는 조기에 발견됩니다. 세 가지 접근 방식 모두에서 좋은 테스트를 작성하는 것이 가능하므로 테스트의 양도 우리의 의사 결정 과정에 영향을 미치지 않습니다.

세 번째로, 변경이 새로운 버그를 도입할 위험에 영향을 미치는 요소는 접근 방식이나 프레임워크가 얼마나 오류를 일으키기 쉬운지입니다. 이는 우리의 의사 결정 과정에서 확실히 관련이 있습니다. 세 가지 접근 방식은 오류 발생 가능성이 다릅니다.

우리는 의사 결정 과정에서 고려해야 할 세 번째 기준, 즉 낮은 오류 발생 가능성을 찾았습니다. 요약하면, 비동기 코드의 좋은 유지보수성을 구성하는 세 가지 중요한 속성은 이해 가능성, 유연성, 그리고 오류 발생 가능성입니다.

이제 이러한 속성을 기반으로 세 가지 접근 방식을 비교해보겠습니다. 이를 위해 표를 만들고 첫 번째 열에 세 가지 접근 방식인 콜백, RxJava, 코루틴을 넣겠습니다. 그리고 첫 번째 행에 우리가 식별한 코드 속성인 이해 가능성, 유연성, 오류 발생 가능성을 넣겠습니다. 이제 각 구현을 살펴보고 이 표를 채워보겠습니다.

안드로이드 스튜디오로 이동하여 콜백 구현을 살펴보겠습니다. 콜백 구현의 전체 코드를 한 화면에 보이도록 폰트 크기를 줄였습니다. 이해 가능성을 평가하는 것은 다소 까다롭습니다. 한편으로는 기본적인 안드로이드, Kotlin, Retrofit에 대한 이해가 있는 모든 개발자가 코드가 무엇을 하는지 이해할 수 있습니다. 특정 프레임워크에 대한 지식이 필요 없기 때문입니다. 예를 들어, Java에서 flatMap이 무엇인지, launch 코루틴 빌더가 무엇을 하는지 등을 찾아볼 필요가 없습니다.

하지만 반면에, 깊은 중첩은 콜백 헬을 초래합니다. 번거로운 오류 처리와 라이프사이클 관리는 여전히 코드를 이해하기 어렵게 만듭니다. 또한, 콜백에서 코드가 실제로 어떤 스레드에서 실행되는지 파악하는 것도 때때로 어렵습니다. 전반적으로, 코드가 무엇을 하는지 파악하는 데 시간이 꽤 걸린다고 생각합니다. 따라서 콜백 기반 접근 방식의 이해 가능성은 낮다고 평가합니다.

이제 유연성을 평가해보겠습니다. 코드가 유연하다는 것은 변경하거나 확장하기 쉬운지를 의미합니다. 유연성을 평가하기 위해 가상의 변경 사항을 고려할 수 있습니다. 예를 들어, 각 기능에 대한 상세 정보를 로드하는 세 번째 네트워크 요청을 수행하려면 얼마나 많은 노력이 필요할까요? 또는 가장 최근 버전 두 개의 기능을 동시에 로드하는 것이 얼마나 쉬울까요? 또는 네트워크 요청이 실패할 때 재시도나 타임아웃 동작을 구현하는 것이 얼마나 쉬울까요?

추가 요청을 수행하려면 콜백 헬이 더욱 심화되고, 오류 처리와 라이프사이클 관리가 더욱 복잡해질 것입니다. 또한, 재시도나 타임아웃 동작을 코드에 추가하는 것도 간단하지 않습니다. 콜백으로 더 복잡한 시나리오를 구현하는 방법을 보여주기 위해, 콜백을 사용하여 더 복잡한 유스케이스를 구현했습니다. 이는 use case seven callbacks 패키지에 위치하고 있으며, timeout과 retry를 포함한 콜백 ViewModel입니다. 여기서 두 개의 네트워크 요청을 병렬로 수행하고 재시도 및 타임아웃 로직을 구현했습니다. 자세히 설명하지는 않겠지만, 이 유스케이스가 콜백으로 구현하기 얼마나 비트러렸는지 바로 알 수 있습니다. 비디오를 일시 정지하고 코드를 직접 공부해보세요. 결론적으로, 콜백 접근 방식의 유연성은 낮다고 평가합니다.

이제 유스케이스 두와 콜백 구현으로 돌아가 콜백 솔루션의 오류 발생 가능성을 평가해보겠습니다. 여기서는 오류를 범하기가 매우 쉽습니다. 예를 들어, 오류 처리나 사용자가 화면을 떠날 때 수행 중인 요청을 취소하는 것을 잊어버리기 쉽습니다. 일반적인 규칙은 논리가 복잡할수록 결함을 도입할 가능성이 높다는 것입니다. 전반적으로, 이 코드는 매우 복잡하다고 생각하며, 따라서 매우 오류가 발생하기 쉽다고 평가합니다.

이제 콜백 접근 방식에 대한 표를 채워보겠습니다. 이해 가능성은 낮고, 유연성도 낮으며, 오류 발생 가능성은 매우 높다고 결론지었습니다.

다음으로, Java를 사용한 구현을 살펴보겠습니다.

이 접근 방식의 이해 가능성을 평가해보겠습니다. 개발자가 이 코드를 이해하는 데 얼마나 걸릴까요? 물론, 이는 개발자가 Java에 얼마나 경험이 있는지에 따라 다릅니다. 경험이 있다면 어렵지 않을 것이지만, Java에 대한 이해가 없는 개발자는 상당한 양의 연구를 해야 할 것입니다. 이는 코드가 비전통적이고 RxJava와 같은 리액티브 프로그래밍에 특정한 많은 구문을 포함하고 있기 때문입니다. 전체 스트림이 flatMap, subscribeOn, observeOn, subscribeBy와 같은 연산자를 기반으로 구축되어 있습니다. 따라서 개발자는 코드의 각 줄이 실제로 무엇을 하는지 연구해야 합니다. 전반적으로, 이 코드는 Java에 특화된 많은 구문을 포함하고 있기 때문에 이해하기 쉽지 않습니다. 따라서 이해 가능성을 중간으로 평가합니다.

이제 유연성에 대해 논의해보겠습니다. 이 접근 방식은 매우 유연하다고 생각합니다. 추가 요청을 수행하려면 스트림에 추가 flatMap을 추가하여 네트워크 요청을 병렬로 수행할 수 있습니다. 예를 들어, SIP 연산자를 사용할 수 있습니다. 재시도나 타임아웃 동작을 구현하기 위해 다른 편리한 연산자들도 많이 있습니다. 저는 use case seven timeout and retry 패키지에 위치한 RxJava로 구현한 use case six을 구현했습니다. 여기서 위에서 언급한 zip, timeout, retry와 같은 연산자를 사용하고 있습니다. 따라서 이 use case seven의 콜백 구현보다 훨씬 짧고, 실제로 그렇게 복잡하지 않습니다.

이제 우리의 구현으로 돌아가 오류 발생 가능성에 대해 이야기해보겠습니다. 콜백을 사용할 때보다는 오류 발생 가능성이 낮다고 생각하지만, 여전히 실수를 하기 쉽습니다. 예를 들어, 라이프사이클 관리를 직접 신경 써야 하고, 사용자가 화면을 떠날 때 디스포저블을 정리해야 합니다. RxJava는 리액티브 프로그래밍 스타일, 즉 완전히 다른 패러다임을 사용하기 때문에 복잡합니다. 대부분의 개발자가 친숙하지 않은 스타일로 작업할 때 실수를 할 가능성이 더 큽니다. 또한, 일부 연산자가 직관적이지 않게 작동하거나 생각했던 것과 다르게 작동할 수 있습니다. 전반적으로, 오류 발생 가능성을 중간으로 평가합니다.

이제 Java에 대한 표를 채워보겠습니다. 이해 가능성은 중간, 유연성은 높으며, 오류 발생 가능성은 중간으로 결론지었습니다.

마지막으로, 코루틴 기반 구현을 분석해보겠습니다.

제 의견으로는, 이 구현은 ViewModel 스코프에서 새로운 코루틴을 시작하는 코드 줄을 제외하면 매우 이해하기 쉽습니다. 코루틴에 대한 경험이 없는 개발자도 쉽게 이해할 수 있습니다. 이는 순차적으로 위에서 아래로 실행되는 일반적인 명령형 코드이기 때문입니다. 코루틴 접근 방식은 매우 유연합니다. 추가 네트워크 요청을 하려면 Retrofit의 다른 suspend 함수를 호출하여 병렬로 네트워크 요청을 수행하면 됩니다. async 코루틴 빌더의 힘을 활용할 수 있습니다. 재시도 동작은 자체적으로 더 높은 수준의 함수를 작성함으로써 쉽게 구현할 수 있습니다. use case seven timeout and retry 패키지의 구현을 열어보면, 두 개의 네트워크 요청을 병렬로 수행하고, 재시도 및 타임아웃 함수를 사용하고 있음을 알 수 있습니다. 이 구현은 RxJava 구현보다 다소 장황하지만, 재시도를 위한 predefined operator를 사용하지 않고, 자체적으로 높은 수준의 retry 함수를 작성했기 때문에 무엇을 하는지 명확하게 보이고, Java 라이브러리의 predefined operator에 숨겨진 마법이 없습니다. 전반적으로, 코루틴을 사용하는 것은 매우 유연하다고 생각합니다.

이제 Use case two의 코루틴 기반 구현으로 돌아가 오류 발생 가능성에 대해 이야기해보겠습니다. 코루틴의 큰 장점은 코루틴 내의 코드를 전통적인 명령형 스타일로 작성할 수 있다는 것입니다. 모든 개발자가 이 스타일에 익숙하기 때문에 코루틴을 사용하는 것이 오류가 발생하기 쉽지 않다고 생각합니다. 또 다른 이유는 대부분의 경우 predefined 코루틴 스코프를 사용하면 라이프사이클 관리가 자동으로 이루어진다는 것입니다. Kotlin 컴파일러가 새로운 코루틴을 특정 스코프에서 시작하도록 강제하기 때문에 라이프사이클 관리를 신경 쓸 수 없습니다.

이제 우리의 발견을 깔끔한 표에 추가해보겠습니다. 코루틴 기반 구현의 이해 가능성과 유연성은 높고, 오류 발생 가능성은 낮다고 결론지었습니다. 따라서 이 표는 코루틴이 현재 안드로이드에서 비동기 프로그래밍을 하는 데 가장 좋은 방법이라고 생각하는 이유를 잘 보여줍니다.

한 가지 분명히 하고 싶은 것은, 코루틴이 비동기 및 다중 스레드 코드를 매우 복잡한 특성을 단순하게 만들어주는 만병통치약은 아니라는 것입니다. 여전히 오류 처리의 정확한 작동 방식과 같은 미묘한 점들이 있습니다. 그러나 저는 코루틴이 현재 비동기 및 다중 스레드 코드를 다루는 데 가장 좋은 추상화를 제공한다고 생각합니다.

또한, 코루틴은 Google에서 안드로이드에서 비동기 프로그래밍의 선호 방식으로 홍보하고 있으며, 대부분의 AndroidX 라이브러리와 Jetpack 라이브러리는 내장된 지원을 받습니다. 코루틴은 단순한 타사 라이브러리가 아니라 Kotlin 프로그래밍 언어에 내재된 프레임워크입니다. 따라서 Kotlin을 뒤에서 개발하는 JetBrains와 Google로부터 일류 지원을 받아, 빠른 버그 수정, 지속적인 발전 및 활발한 개선의 이점을 얻을 수 있습니다. 현재로서는 코루틴 작업이 미래에 중단될 이유가 없습니다. 개인적으로 몇 년 후에는 더 많은 안드로이드 개발자들이 RxJava보다 코루틴에 대한 전문 지식을 가지고 있을 것으로 기대합니다. 따라서 RxJava 경험보다 코루틴 경험을 가진 새로운 팀원을 찾고 온보딩하는 것이 실제로 더 쉬워질 것입니다. 이것도 코루틴을 선호하는 또 다른 이유입니다.

또한, RxJava를 사용하여 제대로 작동하는 애플리케이션이 있고 그것에 만족한다면, 코루틴으로 전환할 실제 이유가 없다는 점도 언급하고 싶습니다. 이 주장은 Google의 전문가들과 안드로이드 커뮤니티의 다른 리더들에 의해 뒷받침됩니다. 그러나 저는 내일 새로운 안드로이드 프로젝트를 시작한다면, 확실히 Kotlin Coroutines를 사용해야 한다고 생각합니다.


![](www.udemy.com_course_coroutines-on-android_learn_lecture_19312014.png)