## **구조적 동시성(Structured Concurrency) vs 비구조적 동시성(Unstructured Concurrency)**

지금까지 구조적 동시성(Structured Concurrency)에 대해 다루었다면, 이제 그 **반대 개념인 비구조적 동시성(Unstructured Concurrency)**에 대해 알아봅니다. 비구조적 동시성은 대부분의 기존 프로그래밍 언어에서 기본적으로 사용하는 동시성 처리 방식입니다. 아래에서 두 개념을 비교하며, 구조적 동시성이 제공하는 주요 이점과 비구조적 동시성의 한계를 살펴보겠습니다.

### **1. 주요 차이점 비교**

#### **1.1. 논리적 범위(Logical Scope)**

• **구조적 동시성**:
	• 모든 코루틴은 **유한한 수명(scope)** 내에서 시작됩니다.
	• 코루틴 스코프는 작업의 시작과 종료를 관리하며, 자동으로 자원을 해제합니다.
	• 예: CoroutineScope를 통해 코루틴 시작.

• **비구조적 동시성**:
	• 스레드나 작업은 **글로벌 컨텍스트**에서 시작됩니다.
	• 수명 관리가 자동으로 이루어지지 않으며, 개발자가 직접 추적하고 수동으로 취소해야 합니다.
	• 잘못된 관리로 인해 메모리 누수나 CPU 자원 낭비가 발생할 수 있습니다.


**1.2. 계층 구조(Hierarchy)**

• **구조적 동시성**:
	• 같은 스코프에서 시작된 코루틴들은 부모-자식 관계를 형성하여 계층 구조를 만듭니다.
	• 이 계층 구조는 작업 간 의존성을 관리하며, 부모 코루틴이 자식 코루틴의 완료를 기다립니다.

• **비구조적 동시성**:
	• 스레드는 서로 독립적으로 실행되며, **계층 구조가 형성되지 않습니다**.
	• 작업 간의 의존성을 개발자가 직접 관리해야 합니다.

**1.3. 부모-자식 관계**

• **구조적 동시성**:
	• 부모 코루틴은 모든 자식 코루틴이 완료될 때까지 대기합니다.
	• 작업 완료 순서가 자연스럽게 정리됩니다.

• **비구조적 동시성**:
	• 스레드는 독립적으로 실행되기 때문에, **종료 순서**를 개발자가 직접 조정해야 합니다.
	• 의존 관계가 있는 스레드를 잘못 관리하면 프로그램 충돌이나 데이터 손상이 발생할 수 있습니다.

**1.4. 취소(Cancellation)**

• **구조적 동시성**:
	• 부모 코루틴이 취소되면, 해당 부모에서 실행된 모든 자식 코루틴이 자동으로 취소됩니다.
	• 취소는 계층 구조를 따라 재귀적으로 이루어집니다.

• **비구조적 동시성**:
	• 스레드 간의 취소가 자동으로 이루어지지 않습니다.
	• 특정 스레드가 취소되었을 때, 관련 없는 스레드까지 수동으로 취소해야 하는 경우가 많습니다.
	• 이는 개발자가 관리해야 하므로 오류 가능성이 높아집니다.

  

**1.5. 예외 처리(Exception Handling)**

• **구조적 동시성**:
	• 자식 코루틴에서 발생한 예외는 부모로 **자동 전파**됩니다.
	• 부모의 Job 유형에 따라 형제 코루틴 취소 여부가 결정됩니다(Job vs SupervisorJob).
	• 예외가 전파되더라도 부모-자식 간 관계가 유지됩니다.

• **비구조적 동시성**:
	• 스레드에서 발생한 예외는 전역적으로 관리되지 않으며, **각 스레드에서 수동으로 처리**해야 합니다.
	• 예외를 놓치면 관련된 다른 스레드가 계속 실행되거나 프로그램이 충돌할 수 있습니다.

### **2. 비구조적 동시성의 문제점**

1. **수동 관리의 복잡성**:

• 스레드의 시작, 종료, 취소 및 예외 처리를 개발자가 직접 관리해야 하므로 복잡성이 증가합니다.

2. **자원 낭비**:

• 스레드가 종료되지 않거나, 불필요한 작업이 계속 실행될 경우 메모리 및 CPU 자원이 낭비됩니다.

3. **동시성 버그**:

• 잘못된 수명 관리나 의존성 처리로 인해 프로그램 충돌 및 데이터 손상이 발생할 수 있습니다.

4. **예외 누락**:

• 스레드에서 발생한 예외를 놓치기 쉽고, 이는 디버깅을 어렵게 만듭니다.

### **3. 구조적 동시성의 이점**

1. **자동 수명 관리**:

• 코루틴은 스코프와 함께 관리되므로 자원의 누수를 방지합니다.

2. **자동 취소 및 정리**:

• 부모-자식 관계를 기반으로 취소가 재귀적으로 이루어집니다.

3. **예외 전파**:

• 예외가 부모로 전파되어 중앙에서 관리되므로 놓치는 일이 없습니다.

4. **간단한 코드**:

• 복잡한 동시성 처리를 단순화하여 코드의 가독성과 유지보수성을 높입니다.

### **4. 비구조적 동시성이 필요한 경우**

코틀린 코루틴에서도 **GlobalScope**를 사용하여 비구조적 동시성을 구현할 수 있습니다. 하지만 이는 매우 제한적인 경우에만 사용해야 합니다.

```kotlin 

```
  

**GlobalScope의 문제점**

• 코루틴은 글로벌 컨텍스트에서 실행되므로, 프로그램 종료 시 정리되지 않을 수 있습니다.
• 부모-자식 관계가 없으므로, 취소 및 예외 처리가 자동으로 이루어지지 않습니다.

  

### **5. 정리**


  

### **결론**

• **구조적 동시성**은 자원의 효율적 관리, 자동화된 취소 및 예외 처리를 제공하여 동시성 작업을 안정적으로 관리할 수 있습니다.
• **비구조적 동시성**은 전통적인 방식으로 더 많은 유연성을 제공하지만, 개발자가 모든 작업을 직접 관리해야 하므로 오류 가능성이 높습니다.
• 가능하면 구조적 동시성을 사용하고, **비구조적 동시성(GlobalScope)**은 꼭 필요한 경우에만 사용하는 것이 좋습니다.
