
|**시대/흐름**|**아키텍처 스타일**|**특징**|**주요 이유 및 기술 변화**|
|---|---|---|---|
|1세대 (~1990)|**모놀리식 (Monolithic)**|- 모든 기능을 하나의 코드베이스로 개발- 배포도 하나로|단순한 비즈니스 요구, 개발과 운영이 작았기 때문에 하나로 구성함|
|2세대 (~2000)|**계층형 아키텍처 (Layered)**3-tier: Presentation / Logic / Data|- UI, 로직, DB 분리- 일반적인 웹 애플리케이션 기본 구조|웹의 등장과 DB 중심의 설계 확산JSP, PHP, .NET, Spring MVC 등|
|3세대 (~2010)|**SOA (Service-Oriented Architecture)**|- 재사용 가능한 서비스- XML, SOAP, ESB 등으로 서비스 통합|기업 내 시스템 통합 (EAI), 복잡한 기업 구조 대응|
|4세대 (~2015)|**마이크로서비스 (Microservices)**|- 각 서비스가 작고 독립적- 팀별로 배포/운영- REST, Docker, Kafka, CI/CD|클라우드, DevOps, 스케일링, 민첩한 조직 요구|
|5세대 (~2020)|**서버리스 아키텍처 (Serverless / FaaS)**|- 인프라 신경 안 써도 됨- 이벤트 기반 함수 단위 개발- 예: AWS Lambda|비용 절감, 짧은 개발 주기, 무한 확장 대응|
|6세대 (~Now)|**모듈식 아키텍처 / 모듈러 모놀리식 / 헥사고날 아키텍처 (Hexagonal, Clean Architecture)**|- 마이크로서비스의 과도한 복잡성 해결- 내부는 깔끔하게 계층화, 외부는 유연히 통합|DDD, 테스트 중심, 유지보수 효율성 강조Clean Architecture, 포트 & 어댑터|
|병행 흐름|**이벤트 중심 아키텍처 (EDA)**|- 서비스 간 직접 호출 대신 이벤트로 통신- 느슨한 결합, 확장성↑|Kafka, RabbitMQ 등으로 이벤트 기반 설계 확산비동기 처리 필수 서비스 증가|

---

# **📈 타임라인 흐름으로 보기**

```
Monolithic (1980s~2000s)
  ↓
Layered (3-tier, MVC 등)
  ↓
SOA (2000s 중후반)
  ↓
Microservices (2010~)
  ↓
Serverless / FaaS (2015~)
  ↓
모듈러 모놀리식 / Clean / Hexagonal (2020~)
```

- 🎯 **DDD(도메인 주도 설계)**는 마이크로서비스 이후 본격적으로 조명되며
    
    헥사고날 아키텍처, Clean Architecture와도 자연스럽게 연결됩니다.
    

---

# **🧩 각 아키텍처의 선택 기준**

|**아키텍처**|**선택 이유**|**사용 시 고려점**|
|---|---|---|
|모놀리식|단순한 프로젝트, MVP 빠른 개발|커지면 관리 어렵고, 의존성 복잡|
|3계층|명확한 역할 구분, 유지보수 편함|모든 비즈니스가 이 구조에 맞지 않음|
|SOA|복잡한 기업 통합 필요 시|ESB 도입과 과도한 XML 처리 복잡성 ↑|
|마이크로서비스|팀 단위 개발, 빠른 배포, 유연한 확장|운영·테스트·트랜잭션 분산 등 복잡성 ↑|
|서버리스|이벤트 기반, 비용 절감, 민첩 개발|상태관리, 테스트 복잡, 추적 어려움|
|헥사고날/클린|도메인 중심, 테스트 용이, 유지보수 좋음|구조 설계에 대한 이해 필요, 학습곡선 ↑|

---

# **🧠 요약**

✅ 아키텍처는 다음과 같은 축에서 진화했습니다:

- **규모 확대 (단일 → 분산 → 기능 단위)**
- **속도와 민첩성 (배포 주기 단축)**
- **운영 효율성 (DevOps, 클라우드, Serverless)**
- **도메인 이해 중심 (DDD → 헥사고날, 클린 아키텍처)**
