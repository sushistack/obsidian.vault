
# **오픈 호스트 서비스 패턴 (Open Host Service, OHS)**

---

## **1. 개념**

- **하나의 바운디드 컨텍스트(제공자)가 자신만의 도메인 모델과 기능을 보호하면서, 외부 사용자(다른 BC)들이 접근 가능한 ‘명확하고 표준화된’ API(서비스)를 공개하는 패턴**
    
- 제공자는 내부 모델과 구현을 감추고, 외부에 공개된 서비스 인터페이스를 통해서만 접근 허용
    
- 서비스 인터페이스는 **표준화, 명확성, 안정성**을 갖추어야 하며, 재사용 가능하고 확장성이 좋음
    
- 사용자 컨텍스트는 이 API를 통해 필요한 기능을 이용함
    

---

## **2. 그림 설명**

```
+-----------------------+    API / 서비스 인터페이스      +-----------------------+
|  사용자 바운디드 컨텍스트  | <---------------------> |  제공자 바운디드 컨텍스트  |
| (User Context)         |                                            | (Provider Context)       |
|                        |                                            |                         |
|  - 내부 모델 독립적 사용  |                                            |  - 내부 모델 숨김           |
|  - API 통해 기능 이용    |                                            |  - 명확한 서비스 인터페이스 제공 |
+-----------------------+                                            +-----------------------+
```

- 제공자 컨텍스트가 외부에 명확한 서비스 API를 오픈
    
- 사용자 컨텍스트는 API를 통해 기능을 호출
    

---

## **3. 코드 예시 (Kotlin)**

  

### **3-1. 제공자 컨텍스트 (Provider Context)**

```
package com.example.provider

// 내부 도메인 모델
data class Customer(
    val id: String,
    val name: String,
    val email: String
)

// 오픈 호스트 서비스: 외부에 공개되는 인터페이스
interface CustomerService {
    fun getCustomerById(id: String): CustomerDTO
}

// DTO (외부 노출용 데이터)
data class CustomerDTO(
    val id: String,
    val name: String
)

// 구현체
class CustomerServiceImpl : CustomerService {

    // 내부 도메인 모델 저장소(가정)
    private val customers = listOf(
        Customer("c001", "Alice", "alice@example.com"),
        Customer("c002", "Bob", "bob@example.com")
    )

    override fun getCustomerById(id: String): CustomerDTO {
        val customer = customers.find { it.id == id }
            ?: throw IllegalArgumentException("Customer not found")
        // 내부 도메인 모델을 DTO로 변환해서 반환
        return CustomerDTO(customer.id, customer.name)
    }
}
```

---

### **3-2. 사용자 컨텍스트 (User Context)**

```
package com.example.user

import com.example.provider.CustomerDTO
import com.example.provider.CustomerService

class UserClient(val customerService: CustomerService) {
    fun printCustomerName(id: String) {
        val customer: CustomerDTO = customerService.getCustomerById(id)
        println("Customer name is ${customer.name}")
    }
}
```

---

## **4. 요약**

|**구분**|**내용**|
|---|---|
|목적|내부 모델 보호, 외부에 명확한 서비스 API 제공|
|접근 방법|서비스 인터페이스(인터페이스, DTO 등) 통해서만 접근 허용|
|장점|내부 구현 변경 자유로움, API 안정성 확보|
|단점|API 설계와 유지보수 비용 발생|
|사용 시기|여러 BC가 제공자 기능을 공유, 외부에 안정적 기능 제공 필요할 때|

---

필요하면 REST API나 메시지 기반 오픈 호스트 서비스 구현 예시도 알려드릴게요!