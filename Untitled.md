
안녕하세요, 티맵 백엔드 엔지니어에 지원한 김종민입니다. 

제가 해당 직무에 지원한 이유는 
유저 별 요청에 대한 최적화된 경로와 공간 데이터를 활용하여 안정적이고 정확하게 서비스를 할 수 있을까? 라는 궁금증으로 부터 출발했습니다. 

저는 지난 5년간 대용량 트래픽의 처리를 포함하여 로그성 데이터 처리, 포인트 계산, 비동기 처리 등의 다양한 프로젝트를 수행하며, 안정적인 서비스를 개발 및 운영 하는데 주력해 왔습니다.
비록 도메인은 다르지만 그동안 쌓아온 경험을 바탕으로 티맵 서비스에 기여하고 싶습니다, 감사합니다.


### API 변경

페이코 앱이 오픈 됨과 동시에 가장 처음 보이는 화면의 API의 구조를 개선하고 안정적으로 변경한 프로젝트라고 할 수 있습니다. 안정적으로 변경했다고 표현한 이유는 해당 API에 대한 구조를 개선한 새로운 버전을 실제 트래픽으로 테스트할 수 있는 쉐도우 테스트를 통해서 변경했기 때문입니다.

간략하게 설명 드리면, (특정 트래픽 혹은 서버 에서만)기존 v1 로직과는 별개로 새로운 스레드에서 v2 버전의 로직을 실행하게 합니다. 
v1은 그대로 응답을 내려주고, v2 는 v1의 응답과 비교를 해서 응답의 일치여부를 확인하는 로직을 구현하여 리포트를 1일 1회 전달하는 방식을 사용했습니다.

단위 테스트도 열심히 작성했고, 알파환경에서 테스트를 진행했을 때는 이슈가 없어, 자신감 있게 배포를 진행했습니다. 그러나 배포 최초에는 일치율이 굉장히 낮았었고, 점진적으로 시간을 들여서 일치율을 올리는데 노력을 기우렸습니다.

=> 이런식으로 배포를 진행한 이유는?

1. 앱 오픈 시, 요청되는 api 이기 때문에, 안정성이 최우선적으로 보장이 되었어야 했습니다.
2. 또한 v1과 v2의 응답의 일치성이 보장되어야 했습니다.
3. 데이터 구조와 서비스로직의 복잡도가 높아서 유닛/통합 테스트를 진행한다고 해도 데이터 모든 유저의 케이스를 대응하기는 어려웠습니다.

=> 어려웠던 점

1. 저를 제외한 많은 개발자들이 각자의 생각과 방식으로 개발이 되어 있어서 기존 코드를 이해하는데 굉장한 시간이 필요했습니다.
2. 개선 작업을 진행하면서 내부적인 구조를 팀원 분들에게 공유하고 의견을 취하는 부분에서도 굉장히 많은 시간과 이야기가 오갔던 것 같습니다.
3. 응답의 순서에 대한 랜덤성 데이터들이 있어서 이런 부분들을 예외처리하는데 어려움이 조금 있었습니다.

=> 장애 포인트?

서비스에 대한 직접적인 장애가 발생한 적은 없고, 한 대의 서버만 2배의 트래픽을 받는 상황이되어 트래픽 내에서도 확률적으로 데이터를 받도록 수정했습니다.

---
### Github Actions 적용

왜 변경하신건가요?
=> 기존 시스템에서 리소스 사용에 대한 이슈가 있었습니다. 젠킨스를 사용중이 었는데, 젠킨스를 사용하는 유형은 크게 배치성 잡과 빌드를 사용하고 있었습니다. 그런데 점차 배치 잡의 개수가 늘어나고, 빌드할 프로젝트들이 늘어나면서 서버 리소스 사용량이 증가하면서 운영 배치 잡들에 영향을 미치는 상황이 었습니다.

따라서 빌드는 빌드대로 따로 분리하는 것이 좋다고 판단하게 되었고, github actions 를 사용하여 분리 작업을 진행했습니다.

리소스

분리작업을 진행하면서, github 이벤트에 대한 빌드 자동화, 정적분석, 코드 커버리지 리포트 등의 기능들을 함께 추가했습니다.

어떤 차이가 있나요?
1. 스케일링이 굉장히 단순합니다.
2. github actions 내부적으로 다양한 캐시를 지원합니다.
3. 다양한 변수 및 시크릿 값들을 손쉽게 관리할 수 있습니다.
4. github cli 등을 이용하여 다양한 정보들을 workflow 에서 사용할 수 있습니다.

어려웠던 점?
	1. 사내 정책으로 사용할 수 있는 마켓에 등록된 actions 들은 사용 불가
	2. 생각보다 사용중인 프로젝트가 많아서 공수가 많이 들었음.
	3. 멀티 모듈 프로젝트에서 각 모듈별 자동빌드 로직 구현


#### 추가 질문

1. **팀의 기존 빌드 및 배포 프로세스를 GitHub Actions로 전환한 과정을 설명해 주시겠어요?**

기존에 저희 팀은 빌드와 배포를 수동으로 진행하거나 자체 구축한 스크립트를 사용하고 있었습니다. 그러던 중 사내에서 GitHub Enterprise의 Actions 기능이 오픈되었고, 이를 활용하면 더 효율적인 빌드 및 배포 프로세스를 구축할 수 있을 것이라고 판단했습니다. 저는 팀에 이 변화를 제안하고, 기존 프로세스를 GitHub Actions로 전환하는 작업을 주도적으로 진행했습니다. 이를 위해 기존 빌드 스크립트를 분석하고, 필요한 워크플로우를 정의하여 GitHub Actions에 맞게 재구성하였습니다.

• **이 변화를 팀에 제안한 주요 이유는 무엇이었나요?**

주요 이유는 자동화를 통해 빌드 및 배포 과정의 효율성을 높이고, 인적 오류를 최소화하기 위해서였습니다. 또한 GitHub Actions는 GitHub와의 통합성이 높아 코드 변경에 따른 CI/CD 파이프라인을 손쉽게 구성할 수 있다는 장점이 있었습니다.

• **팀 내에서 GitHub Actions의 원활한 도입을 어떻게 보장하셨나요?**

팀원들에게 GitHub Actions의 장점과 사용 방법을 공유하는 세미나를 개최하고, 초기 설정과 사용법에 대한 문서를 작성하여 배포했습니다. 또한 도입 초기에 발생할 수 있는 문제를 해결하기 위해 지원 채널을 마련하고, 피드백을 적극 수렴하여 워크플로우를 개선했습니다.

2. **빌드 시간을 38% 감소시켰다고 언급하셨는데, 이를 달성하기 위해 어떤 전략이나 최적화를 구현하셨나요?**

빌드 시간을 감소시키기 위해 캐시 기능을 활용하여 반복적인 의존성 설치 시간을 줄였고, 병렬 작업을 통해 테스트와 빌드 과정을 동시에 진행하도록 워크플로우를 설계했습니다. 또한 불필요한 빌드 단계를 제거하고, 경량화된 도커 이미지를 사용하여 전체적인 빌드 효율을 향상시켰습니다.

• **빌드 시간의 감소를 어떻게 측정하고 검증하셨나요?**

GitHub Actions에서 제공하는 빌드 로그와 메트릭스를 활용하여 빌드 시간의 변화를 모니터링했습니다. 이전 빌드 프로세스와 새로운 프로세스의 평균 빌드 시간을 비교하여 38%의 감소를 확인하였습니다.

• **이 감소가 팀의 전체적인 워크플로우와 효율성에 어떤 영향을 미쳤나요?**

빌드 시간이 단축됨으로써 개발자들이 코드 변경 후 결과를 확인하는 시간이 줄어들었고, 이는 빠른 피드백 루프를 형성하여 개발 속도를 향상시켰습니다. 또한 자동화된 프로세스로 인해 수동 작업이 줄어들어 업무 효율이 전반적으로 상승했습니다.

3. **워크플로우에 정적 분석, 빌드 자동화, 결과물 버저닝, 알림 등을 어떻게 통합하셨나요?**

먼저, 코드 퀄리티를 유지하기 위해 정적 분석 도구를 빌드 프로세스의 초기 단계에 포함시켰습니다. 빌드 자동화는 GitHub Actions의 이벤트 트리거를 활용하여 코드 푸시나 풀 리퀘스트 시 자동으로 실행되도록 설정하였습니다. 결과물 버저닝은 Git 태그와 연동하여 자동으로 버전 번호를 생성하고, 빌드 아티팩트에 적용하였습니다. 마지막으로 빌드 및 테스트 결과, 그리고 정적 분석 결과를 팀 채팅 채널로 알림이 전송되도록 하여 팀원들이 즉각적으로 확인할 수 있게 했습니다.

• **이러한 통합을 위한 명확한 정책을 수립하셨는데, 그 예시를 들어 주실 수 있나요?**

예를 들어, 코드 커밋 메시지에 특정 형식을 적용하고, 이를 기반으로 자동 버저닝을 수행하는 정책을 수립했습니다. 또한 코드 스타일과 린팅 규칙을 정하고, 정적 분석 단계에서 이를 검증하여 규칙을 위반한 코드에 대해 빌드를 실패시키는 정책을 적용했습니다.

• **CI 결과와 팀 내 컨벤션을 결합함으로써 팀 내의 커뮤니케이션이나 협업이 어떻게 향상되었나요?**

CI 결과가 팀 채널로 자동 알림되면서 팀원들이 코드 상태를 실시간으로 파악할 수 있게 되었습니다. 이를 통해 문제 발생 시 빠르게 대응할 수 있었고, 코드 컨벤션 위반 사항도 즉시 공유되어 코드 리뷰 과정이 효율적으로 개선되었습니다. 전체적으로 팀 내 협업과 커뮤니케이션이 강화되어 개발 프로세스의 품질이 향상되었습니다.




---

### 공동 결제 기반 이벤트 시스템

**1. 공동 결제 정보를 기반으로 유저에게 혜택을 제공하는 시스템을 구축하면서 어떤 도전과제를 경험하셨나요?**

공동 결제 정보를 활용한 시스템을 구축하면서 데이터 수집과 처리의 복잡성이 가장 큰 도전과제였습니다. 여러 결제 수단과 플랫폼에서 발생하는 다양한 형태의 데이터를 실시간으로 수집하고, 이를 일관된 형식으로 변환하여 정확하게 처리해야 했습니다.

• **꼬리질문 1:** 이러한 도전과제를 어떻게 해결하셨는지 구체적으로 설명해 주실 수 있나요?

데이터 수집 단계에서 Kafka를 도입하여 다양한 소스로부터 실시간 데이터 스트리밍을 구현했습니다. 또한, 데이터 변환 과정에서는 표준화된 스키마를 정의하고, ETL 배치를 통해 데이터의 일관성을 유지했습니다. 이를 통해 복잡한 데이터 처리 과정을 자동화하고 안정성을 확보할 수 있었습니다.

• **꼬리질문 2:** 이 과정에서 얻은 가장 큰 교훈이나 인사이트는 무엇이었나요?

복잡한 시스템일수록 모듈화와 표준화가 중요하다는 것을 깨달았습니다. 또한, 실시간 데이터 처리에서는 작은 지연도 전체 시스템에 영향을 미칠 수 있으므로 성능 최적화와 효율적인 아키텍처 설계의 중요성을 배우게 되었습니다.

**2. 유저에게 지급해줄 포인트의 계산 및 검증 로직에 대해 50여 개의 유닛 테스트를 작성하셨다고 하셨는데, 테스트 케이스를 어떻게 설계하셨나요?**

포인트 계산 로직의 모든 가능한 시나리오를 포괄하기 위해 경계 값 분석과 동등 분할 기법을 활용하여 테스트 케이스를 설계했습니다. 정상적인 입력뿐만 아니라 예외 상황, 오류 조건 등을 포함하여 총 50여 개의 유닛 테스트를 작성하여 로직의 안정성과 정확성을 검증했습니다.


• **꼬리질문 1:** 테스트 과정에서 발견된 주요 이슈는 무엇이었으며, 어떻게 해결하셨나요?

테스트를 진행하면서 일부 경계 값에서 포인트가 정확히 계산되지 않는 오류를 발견했습니다. 이는 로직에서 특정 조건에 대한 처리가 누락되었기 때문이었습니다. 해당 부분을 수정하고 추가적인 테스트 케이스를 작성하여 동일한 문제가 재발하지 않도록 조치했습니다.

• **꼬리질문 2:** 유닛 테스트를 작성하면서 어떤 도구나 프레임워크를 사용하셨나요?

Java에서는 JUnit과 Mockito를, Kotlin에서는 Kotest를 사용하여 유닛 테스트를 작성했습니다. 이러한 도구들을 활용하여 테스트 작성과 모의 객체 생성이 용이해졌고, 테스트의 효율성과 가독성을 높일 수 있었습니다.

**3. 결제팀의 Kafka와 연동하여 포인트 갱신 시간을 2시간에서 10분으로 단축하셨다고 했는데, 이를 구현하기 위해 어떤 접근 방식을 취하셨나요?**

기존에는 2시간 주기의 배치 작업으로 포인트를 갱신했지만, Kafka를 활용하여 실시간 데이터 처리를 구현했습니다. 결제 이벤트를 Kafka 토픽으로 받아서 실시간으로 처리하고, 포인트 계산 로직을 트리거하여 갱신 시간을 10분으로 단축했습니다.
• **꼬리질문 1:** Kafka를 활용하면서 직면한 기술적인 어려움은 무엇이었고, 이를 어떻게 극복하셨나요?

Kafka 연동 시 데이터 소비자의 오프셋 관리와 메시지 중복 처리 이슈가 있었습니다. 이를 해결하기 위해 Kafka의 컨슈머 그룹을 효율적으로 관리하고, 아이들포텐트 프로듀서 설정을 통해 중복 메시지 전송을 방지했습니다. 또한, 장애 발생 시를 대비하여 메시지 재처리 로직을 구현했습니다.

• **꼬리질문 2:** 포인트 갱신 시간이 단축됨에 따라 시스템 성능이나 안정성에 어떤 영향을 미쳤나요?

갱신 주기가 짧아지면서 시스템 부하가 증가할 것을 우려했지만, 비동기 처리와 스케일링 전략을 적용하여 성능 저하 없이 안정적으로 운영할 수 있었습니다. 결과적으로 유저들은 더욱 빠른 혜택 제공을 경험할 수 있었고, 이는 서비스 만족도로 이어졌습니다.


--- 

### 페이코 기여

래빗 MQ 를 사용한 이유, 레디스를 사용한 이유

--- 

즐거운 점
=> 제가 코드를 작성하는 것도 좋아하지만, 다른 분이 작성한 코드를 보는 것도 좋아합니다. 그래서 코드리뷰를 진행하면 굉장히 많은 내용을 적게 되는데, 이게 또 리뷰를 받으시는 분에게는 부담이 될 수 있잖아요? 리뷰를 남길 때, 질문인지, 단순 의견인지, 꼭 고쳐야하는 내용인지를 명확하게 해서 리뷰하는 편입니다.

리더십을 발휘했던 경험
=> 제가 작성해둔 프로젝트 외에도 다양한 프로젝트를 진행했던 경험이 있었는데요, 3년차 즘에 새로입사하신 분과 함께 작은 프로젝트를 진행했던 경험이 있습니다. 처음으로 제가 전체적인 부분을 담당하면서 같이 개발하시는 분도 함께 챙겨야하는 부분이 어려웠었습니다. 

팀원과의 갈등
=> 네이밍이나 데이터를 저장하는 방식에 대한 의견 충돌이 발생한 적이 많았던 것 같습니다. 충돌이 발생할 때마다 사람들은 정말 다양한 생각을 갖고 있구나 싶으면서도 그럴 수 있다고 생각하게 된 것 같습니다. 결론적으로는 보통 다른 분들에게 요청을 해서 투표를 통해서 해결  했던 경우가 많았던 것 같아요

남들과 다르게 행동했던 것
=> 프론트엔드 관련된 작업을 하면서 css 리소스를 어디 위치시키느냐에 대한 의견이 저만 달랐던 경험이 있었습니다. 지금 생각해보면 제가 주장했던 내용이 좀 이상했던 것 같습니다.