
### **1. JPA의 영속성 컨텍스트(Persistence Context)와 1차 캐시의 동작 원리에 대해 설명해 주세요.**

영속성 컨텍스트는 엔티티 객체를 관리하는 일종의 1차 캐시로, 엔티티의 생명 주기를 관리하고 데이터베이스와의 상호작용을 최적화합니다. 영속성 컨텍스트는 엔티티를 영구 저장소에 저장하거나 조회할 때, 동일한 엔티티에 대한 중복된 데이터베이스 접근을 방지하고 일관성을 유지하는 역할을 합니다. 1차 캐시는 영속성 컨텍스트 내에서 관리되며, 엔티티 매니저가 활성화된 동안 동일한 식별자를 가진 엔티티에 대한 조회는 캐시된 객체를 반환하여 성능을 향상시킵니다.

#### 1. **영속성 컨텍스트의 생명 주기는 어떻게 관리되나요?**

영속성 컨텍스트의 생명 주기는 크게 두 가지 범위로 관리됩니다: 트랜잭션 범위와 애플리케이션 범위. 트랜잭션 범위에서는 영속성 컨텍스트가 트랜잭션의 시작과 함께 생성되고, 트랜잭션이 종료되면 소멸됩니다. 반면, 애플리케이션 범위에서는 스프링의 @PersistenceContext 어노테이션을 사용하여 EntityManager를 주입받을 때, 스프링이 관리하는 빈의 생명 주기와 일치하게 됩니다. 일반적으로 대부분의 경우 트랜잭션 범위의 영속성 컨텍스트가 사용됩니다. 
#### 3. **JPA의 쓰기 지연(Write-behind) 전략에 대해 설명해 주세요.**

쓰기 지연 전략은 JPA가 엔티티의 변경 사항을 즉시 데이터베이스에 반영하지 않고, 트랜잭션이 커밋되거나 flush가 호출될 때 일괄적으로 반영하는 전략입니다. 이를 통해 불필요한 데이터베이스 접근을 줄이고 성능을 최적화할 수 있습니다. 예를 들어, 여러 엔티티의 변경이 있을 경우, JPA는 이들을 하나의 SQL 배치로 처리하여 데이터베이스와의 통신 횟수를 최소화합니다. 또한, 변경 감지를 통해 필요한 경우에만 업데이트를 수행하여 효율성을 높입니다.
#### 4. **1차 캐시와 2차 캐시의 차이점은 무엇이며, 언제 각각을 사용하는 것이 적절한가요?**

1차 캐시는 영속성 컨텍스트 내에서 관리되며, EntityManager가 활성화된 동안 동일한 엔티티에 대한 조회 시 캐시된 객체를 반환합니다. 이는 동일한 트랜잭션 내에서의 데이터 일관성을 유지하고 성능을 향상시키는 데 사용됩니다.

2차 캐시는 애플리케이션 전역에서 공유되는 캐시로, 여러 영속성 컨텍스트 간에 엔티티 데이터를 공유할 수 있습니다. 이는 데이터베이스 조회 횟수를 줄이고 캐시 히트율을 높여 애플리케이션의 전반적인 성능을 향상시키는 데 유용합니다. 2차 캐시는 자주 조회되지만 변경 빈도가 낮은 데이터에 적합하며, Ehcache, Hazelcast 등 다양한 캐시 제공자를 통해 구현할 수 있습니다.

### **2. Spring Data JPA에서 제공하는 다양한 쿼리 메소드(Query Methods) 전략에 대해 설명해 주세요.**

Spring Data JPA는 메소드 이름을 기반으로 자동으로 쿼리를 생성하는 다양한 쿼리 메소드 전략을 제공합니다. 대표적인 전략으로는 findBy, readBy, queryBy, getBy 접두어를 사용한 메소드 명명 규칙이 있으며, 조건절을 메소드 이름에 포함시켜 동적으로 쿼리를 생성할 수 있습니다. 또한, @Query 어노테이션을 사용하여 JPQL이나 네이티브 SQL을 직접 작성할 수도 있고, Querydsl이나 Specifications을 이용한 동적 쿼리 생성도 지원합니다. 이를 통해 개발자는 복잡한 쿼리를 간단하게 작성하고 유지보수할 수 있습니다.
#### 1. **메소드 이름 기반 쿼리 생성의 장단점은 무엇인가요?**

- 장점:
	• **간결함:** 간단한 쿼리는 메소드 이름만으로 쉽게 작성할 수 있어 코드가 간결해집니다.
	• **자동화:** Spring Data JPA가 메소드 이름을 분석하여 자동으로 쿼리를 생성하므로 개발자가 직접 JPQL을 작성할 필요가 없습니다.
	• **유지보수 용이:** 메소드 이름을 통해 쿼리의 의도를 쉽게 파악할 수 있어 유지보수가 용이합니다.

- 단점:
	• **복잡성 제한:** 복잡한 쿼리나 다중 조인이 필요한 경우 메소드 이름만으로는 한계가 있습니다.
	• **가독성 저하:** 메소드 이름이 너무 길어지거나 복잡해질 경우 가독성이 떨어질 수 있습니다.
	• **유연성 부족:** 동적으로 변경되는 조건에 대한 유연한 쿼리 작성이 어려울 수 있습니다.
#### 2. **@Query 어노테이션을 사용할 때의 주요 고려사항은 무엇인가요?**

• **쿼리의 정확성:** JPQL이나 네이티브 SQL을 직접 작성하므로, 문법 오류나 논리적 오류가 발생하지 않도록 주의해야 합니다.
• **성능 최적화:** 작성한 쿼리가 성능에 미치는 영향을 고려하여 필요한 인덱스나 최적화 방안을 적용해야 합니다.
• **파라미터 바인딩:** 메소드 파라미터와 쿼리 파라미터의 매칭을 정확하게 해야 하며, @Param 어노테이션을 활용하여 명확하게 지정할 수 있습니다.
• **재사용성:** 동일한 쿼리를 여러 곳에서 사용할 경우, 중복을 피하고 재사용성을 높이기 위해 적절히 관리해야 합니다.
• **보안:** 네이티브 쿼리를 사용할 경우, SQL 인젝션 공격에 취약할 수 있으므로 파라미터 바인딩을 통해 안전하게 처리해야 합니다.

#### 3. **쿼리 메소드의 성능 최적화를 위해 어떤 방법들을 사용할 수 있나요?**

• **페치 조인 사용:** 관련 엔티티를 한 번의 쿼리로 조회하여 N+1 문제를 방지하고 성능을 향상시킬 수 있습니다.
• **프로젝션 사용:** 필요한 필드만 조회하여 불필요한 데이터 로드를 줄이고 네트워크 비용을 절감할 수 있습니다.
• **인덱스 활용:** 자주 조회되는 필드에 인덱스를 추가하여 조회 성능을 개선할 수 있습니다.
• **캐싱 적용:** 2차 캐시를 활용하여 자주 조회되는 데이터를 캐싱함으로써 데이터베이스 접근을 최소화할 수 있습니다.
• **Batch Size 조정:** 대량의 데이터를 처리할 때 배치 크기를 조정하여 효율적인 데이터 처리를 도모할 수 있습니다.
• **네이티브 쿼리 사용:** 복잡한 쿼리나 성능이 중요한 쿼리의 경우 네이티브 SQL을 사용하여 데이터베이스에 최적화된 쿼리를 작성할 수 있습니다.

###  **3. JPA의 엔티티 관계 매핑에서 발생할 수 있는 N+1 문제를 설명하고, 이를 해결하기 위한 방안들을 논의해 주세요.**

N+1 문제는 하나의 쿼리(N)로 여러 관련 엔티티를 조회할 때, 추가적인 N개의 쿼리가 발생하여 성능 저하를 초래하는 문제를 말합니다. 예를 들어, 부모 엔티티를 조회한 후 각 부모 엔티티의 자식 엔티티를 개별적으로 조회하면 총 N+1개의 쿼리가 실행됩니다. 이는 데이터베이스와의 불필요한 통신을 증가시켜 응답 속도를 저하시킵니다.

이를 해결하기 위한 방안으로는 다음과 같은 방법들이 있습니다:

• **페치 조인(Fetch Join):** JPQL에서 JOIN FETCH를 사용하여 관련 엔티티를 한 번의 쿼리로 함께 조회합니다.
• **Batch Fetching:** 설정을 통해 한 번에 여러 엔티티를 배치로 조회하여 쿼리 수를 줄입니다.
• **Entity Graph:** 엔티티 그래프를 정의하여 특정 쿼리에서 필요한 연관 엔티티를 함께 로드하도록 지정합니다.
• **DTO Projection:** 필요한 데이터만을 조회하여 복잡한 연관 관계를 단순화하고 쿼리 수를 줄입니다.
• **캐싱:** 2차 캐시를 활용하여 자주 조회되는 연관 엔티티를 캐싱함으로써 데이터베이스 접근을 최소화합니다.

#### 1. **페치 조인(Fetch Join)이 N+1 문제 해결에 어떻게 도움이 되나요?**

페치 조인은 JPQL에서 JOIN FETCH 키워드를 사용하여 연관된 엔티티를 한 번의 쿼리로 함께 조회할 수 있게 합니다. 이를 통해 부모 엔티티와 자식 엔티티를 조인하여 단일 쿼리로 모든 데이터를 가져오기 때문에 N+1 문제를 효과적으로 해결할 수 있습니다. 예를 들어, SELECT p FROM Parent p JOIN FETCH p.children과 같이 작성하면 부모와 자식 엔티티가 동시에 로드되어 추가적인 쿼리가 발생하지 않습니다. 이는 데이터베이스 접근 횟수를 줄이고 응답 속도를 향상시킵니다.
#### 2. **Batch Fetching과 Entity Graph의 차이점은 무엇인가요?**

• **Batch Fetching:**
	• **동작 방식:** 지정된 배치 크기만큼 엔티티를 한 번에 조회합니다. 예를 들어, N개의 부모 엔티티가 있을 때, Batch Fetching을 사용하면 특정 배치 크기(예: 20) 단위로 자식 엔티티를 조회하여 총 쿼리 수를 줄입니다.
	• **장점:** 페치 조인보다 유연하며, 여러 연관 관계를 동시에 처리할 수 있습니다.
	• **설정:** @BatchSize 어노테이션이나 hibernate.default_batch_fetch_size 설정을 통해 배치 크기를 지정할 수 있습니다.

• **Entity Graph:**
	• **동작 방식:** 엔티티 그래프를 정의하여 특정 쿼리에서 어떤 연관 엔티티를 함께 로드할지 명시합니다. 이를 통해 필요한 데이터만을 효율적으로 조회할 수 있습니다.
	• **장점:** 페치 조인과 유사하게 명시적인 데이터 로딩을 지원하며, 다양한 시나리오에 맞춰 유연하게 사용할 수 있습니다.
	• **설정:** @NamedEntityGraph 어노테이션이나 동적 Entity Graph API를 통해 그래프를 정의하고 적용할 수 있습니다.
#### 3. **Spring Data JPA에서 N+1 문제를 탐지하고 방지하기 위한 도구나 기법이 있나요?**

• **Hibernate Statistics:** Hibernate의 통계 기능을 활성화하여 실행된 쿼리 수를 모니터링하고 N+1 문제를 탐지할 수 있습니다.
• **플레이그라운드(플러그인) 도구:** 예를 들어, Spring Boot 애플리케이션에서 spring.jpa.show-sql과 hibernate.format_sql을 활성화하여 실행된 SQL을 로그로 확인할 수 있습니다. 또한, P6Spy와 같은 JDBC 프록시 도구를 사용하여 쿼리 로그를 상세하게 분석할 수 있습니다.
• **프로파일링 도구:** VisualVM, YourKit과 같은 Java 프로파일러를 사용하여 애플리케이션의 데이터베이스 접근 패턴을 분석할 수 있습니다.
• **Spring Data JPA Auditing:** 일부 라이브러리나 스프링의 기능을 통해 자동으로 N+1 문제를 탐지하고 경고를 발생시킬 수 있습니다.
• **코드 리뷰 및 테스트:** 코드 리뷰 과정에서 연관 관계 매핑과 쿼리 사용 방식을 점검하고, 통합 테스트를 통해 쿼리 수를 모니터링하여 N+1 문제를 사전에 방지할 수 있습니다.


###  **4. Spring Data JPA의 Auditing 기능에 대해 설명하고, 이를 어떻게 커스터마이징할 수 있는지 논의해 주세요.**

Spring Data JPA의 Auditing 기능은 엔티티의 생성 및 수정 시점, 작성자 등을 자동으로 기록하는 기능을 제공합니다. 이를 통해 수동으로 변경 이력을 관리할 필요 없이 일관된 방식으로 감사 정보를 관리할 수 있습니다. 주로 @CreatedDate, @LastModifiedDate, @CreatedBy, @LastModifiedBy 등의 어노테이션을 사용하여 엔티티 필드에 적용합니다.
#### 1. **Auditing 기능을 활성화하기 위해 필요한 설정은 무엇인가요?**

1. **@EnableJpaAuditing 어노테이션 추가:**
2. **AuditorAware**
3. @CreatedDate, @LastModifiedDate, @CreatedBy, @LastModifiedBy 어노테이션을 적용

#### 2. **커스텀 AuditorAware 구현 시 고려해야 할 사항은 무엇인가요?**

• **현재 사용자 정보 제공:** AuditorAware 구현체는 현재 사용자의 정보를 정확하게 제공해야 합니다. 일반적으로 보안 컨텍스트(Security Context)나 세션에서 현재 사용자를 가져옵니다.

• **Optional 반환:** getCurrentAuditor 메소드는 Optional을 반환하므로, 사용자 정보가 없을 경우 Optional.empty()를 반환할 수 있도록 처리해야 합니다.

• **트랜잭션 관리:** Auditor 정보를 가져오는 과정에서 트랜잭션이나 세션과의 상호작용을 신중하게 관리해야 합니다.

• **테스트 용이성:** 테스트 환경에서도 쉽게 Auditor 정보를 주입할 수 있도록 유연하게 구현해야 합니다. 예를 들어, Mock 객체나 스테이블한 값을 반환하도록 설정할 수 있습니다.

• **다양한 사용자 식별자 지원:** 사용자 식별자가 단순한 문자열이 아닌 다른 타입(예: 사용자 ID 객체)일 경우, 해당 타입을 지원하도록 구현해야 합니다.

#### 3. **Auditing 필드 외에 추가적인 변경 추적이 필요할 때는 어떻게 접근하나요?**


###  **5. JPA의 성능 최적화를 위해 사용하는 주요 전략과 그 이유에 대해 설명해 주세요.**

JPA의 성능 최적화를 위해 다양한 전략을 사용할 수 있으며, 이는 애플리케이션의 응답 속도와 자원 사용을 효율적으로 관리하는 데 중요한 역할을 합니다. 주요 전략으로는 캐싱, 페치 전략 조정, 쿼리 최적화, 배치 처리, 지연 로딩과 즉시 로딩의 적절한 사용 등이 있습니다. 이러한 전략들은 데이터베이스 접근을 최소화하고, 메모리 사용을 최적화하며, 전반적인 애플리케이션 성능을 향상시키는 데 기여합니다.
#### 1. **캐싱 전략을 적용할 때 고려해야 할 주요 요소는 무엇인가요?**

• **데이터 일관성:** 캐시된 데이터가 원본 데이터와 일치하도록 일관성 유지 방안을 마련해야 합니다. 캐시 무효화 전략이나 TTL(Time To Live) 설정을 통해 데이터의 신선도를 관리합니다.

• **캐시 범위:** 1차 캐시와 2차 캐시의 사용 범위를 명확히 정의해야 합니다. 1차 캐시는 영속성 컨텍스트 내에서 자동으로 관리되며, 2차 캐시는 애플리케이션 전역에서 공유됩니다.

• **캐시 제공자 선택:** Ehcache, Hazelcast, Redis 등 다양한 캐시 제공자 중 애플리케이션 요구사항에 맞는 적절한 캐시 솔루션을 선택해야 합니다.

• **데이터 접근 패턴 분석:** 자주 조회되는 데이터와 그렇지 않은 데이터를 구분하여 캐싱 전략을 세워야 합니다. 또한, 읽기 전용 데이터와 변경이 잦은 데이터를 다르게 처리할 필요가 있습니다.

• **메모리 사용량:** 캐시가 사용하는 메모리 양을 관리하여 애플리케이션의 전체 메모리 사용량에 영향을 미치지 않도록 해야 합니다. 캐시 사이즈 제한이나 eviction 정책을 설정할 수 있습니다.

• **동시성 관리:** 다중 스레드 환경에서 캐시의 일관성과 동시성을 관리해야 합니다. 캐시 제공자가 제공하는 동시성 제어 메커니즘을 활용할 수 있습니다.

• **캐시 업데이트 전략:** 데이터가 변경될 때 캐시를 어떻게 업데이트할지 결정해야 합니다. 예를 들어, 쓰기 시 캐시를 즉시 업데이트하거나, 읽기 시 최신 데이터를 조회하도록 설정할 수 있습니다.

#### 2. **지연 로딩(Lazy Loading)과 즉시 로딩(Eager Loading)의 적절한 사용 시점은 언제인가요?**
#### 3. **JPA에서 사용하는 SQL 쿼리를 최적화하기 위해 어떤 도구나 기법을 활용하나요?**