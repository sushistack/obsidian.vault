## 1. Spring의 AOP(Aspect-Oriented Programming)에 대해 설명하고, 이를 어떻게 활용하여 애플리케이션의 품질을 개선할 수 있는지 예시를 들어 설명해보세요.


## 2. Spring의 트랜잭션 관리에 대해 설명하고, 프로그래밍 방식과 선언적 방식의 차이점, 그리고 각각의 장단점에 대해 논의해보세요.


## 3. Spring AOP를 사용하여 트랜잭션 관리를 구현할 때 발생할 수 있는 문제점과 이를 해결하기 위한 방안은 무엇인가요? 또한, Spring AOP와 AspectJ AOP의 차이점을 설명해주세요.

Spring AOP를 사용하여 트랜잭션 관리를 구현할 때 몇 가지 문제점이 발생할 수 있습니다. 이러한 문제들은 주로 프록시 기반의 AOP 동작 방식과 트랜잭션 전파(propagation)에 대한 이해 부족에서 기인합니다. 아래에서는 이러한 문제점들과 그 해결 방안에 대해 자세히 설명하겠습니다.


### **1. 자기 호출(Self-invocation) 문제**

**문제점:**

Spring AOP는 프록시 객체를 통해 부가 기능을 추가합니다. 그러나 같은 클래스 내에서 메서드가 서로 호출되는 경우(자기 호출), 프록시를 거치지 않고 직접 호출되기 때문에 트랜잭션 어드바이스가 적용되지 않습니다. 이는 예상치 못한 트랜잭션 관리 실패로 이어질 수 있습니다.

**해결 방안:**

• **구조 분리:** 트랜잭션이 필요한 메서드를 별도의 서비스 클래스로 분리하여 호출하면 프록시를 거치게 되어 어드바이스가 적용됩니다.

• **AspectJ 사용:** Spring AOP 대신 AspectJ를 사용하면 바이트코드 조작을 통해 자기 호출 문제를 해결할 수 있습니다. AspectJ는 컴파일 타임 또는 로드 타임 위빙을 지원하여 이 문제를 근본적으로 해결합니다.


### **2. 프록시 객체의 한계**

**문제점:**

• **프록시 대상의 메서드 제한:** Spring AOP는 기본적으로 public 메서드에만 어드바이스를 적용합니다. private, protected, final 메서드에는 적용되지 않습니다.

• **인터페이스 기반 프록시의 한계:** JDK 동적 프록시는 인터페이스를 구현하는 방식으로 프록시를 생성하기 때문에, 인터페이스에 선언되지 않은 메서드에는 어드바이스가 적용되지 않습니다.

**해결 방안:**

• **CGLIB 프록시 사용:** <aop:config proxy-target-class="true"/> 또는 @EnableTransactionManagement(proxyTargetClass = true) 설정을 통해 CGLIB 기반의 프록시를 사용하면 클래스 기반의 프록시가 생성되어 이러한 제한을 완화할 수 있습니다.

• **메서드 접근 제어자 확인:** 트랜잭션이 필요한 메서드는 가능하면 public으로 선언하여 어드바이스 적용이 가능하도록 합니다.


### **3. 트랜잭션 전파 설정의 오용**

**문제점:**

트랜잭션 전파 속성에 대한 이해 부족으로 인해 예상치 못한 트랜잭션 동작이 발생할 수 있습니다. 예를 들어, REQUIRED와 REQUIRES_NEW의 차이를 잘못 이해하면 트랜잭션 경계가 예상과 다르게 설정됩니다.

**해결 방안:**

• **전파 속성 이해 및 적용:** 트랜잭션 전파 옵션(REQUIRED, REQUIRES_NEW, SUPPORTS 등)의 의미를 정확히 이해하고 상황에 맞게 적용합니다.
• **설계 시 고려:** 트랜잭션 경계를 명확히 정의하고, 메서드 간 호출 관계를 고려하여 전파 속성을 설정합니다.

### **4. 예외 처리와 롤백 규칙**

**문제점:**

Spring은 기본적으로 unchecked 예외(RuntimeException 및 그 하위 클래스)와 Error가 발생할 때만 트랜잭션을 롤백합니다. checked 예외(Exception의 하위 클래스)는 롤백되지 않습니다. 따라서 예상치 못한 예외 처리로 인해 데이터 불일치가 발생할 수 있습니다.

**해결 방안:**

• **rollbackFor 속성 사용:** @Transactional(rollbackFor = Exception.class)와 같이 rollbackFor 속성을 사용하여 롤백이 필요한 예외를 명시적으로 지정합니다.
• **예외 계층 구조 설계:** 비즈니스 로직에 맞게 커스텀 예외를 정의하고, 적절한 예외 계층 구조를 설계하여 트랜잭션 롤백이 원하는 대로 이루어지도록 합니다.


**CGLIB 프록시란 무엇인가요?**

**CGLIB**(Code Generation Library) 프록시는 런타임 시 바이트코드를 생성하여 자바 클래스의 프록시 객체를 만드는 라이브러리입니다. 이는 클래스 상속과 메서드 오버라이딩을 활용하여 원본 객체의 메서드 호출을 가로채고, 추가적인 기능을 제공할 수 있습니다.

**Spring에서의 CGLIB 프록시 사용**

Spring 프레임워크에서는 AOP(Aspect-Oriented Programming)를 구현할 때 프록시 패턴을 활용합니다. 기본적으로 **JDK 동적 프록시**를 사용하지만, 이는 인터페이스를 구현한 객체에만 적용할 수 있다는 제한이 있습니다. CGLIB 프록시는 이러한 제한을 극복하여 **구체 클래스**(Concrete Class)에도 프록시를 적용할 수 있습니다.

• **인터페이스가 없는 클래스 프록시**: 대상 객체가 어떤 인터페이스도 구현하지 않은 경우, CGLIB 프록시를 사용하여 AOP 기능을 적용합니다.

• **proxy-target-class 속성**: @EnableAspectJAutoProxy(proxyTargetClass = true) 또는 <aop:config proxy-target-class="true"/> 설정을 통해 명시적으로 CGLIB 프록시를 사용할 수 있습니다.

**CGLIB 프록시의 작동 방식**

1. **클래스 상속**: CGLIB은 대상 클래스의 서브클래스를 동적으로 생성합니다.
2. **메서드 오버라이딩**: 생성된 서브클래스에서 대상 클래스의 메서드를 오버라이드하여 메서드 호출을 가로챕니다.

3. **메서드 인터셉터 적용**: 오버라이드된 메서드에서 MethodInterceptor를 통해 부가 기능(예: 트랜잭션 관리, 로깅 등)을 추가합니다.
4. **원본 메서드 호출**: 필요에 따라 MethodProxy.invokeSuper()를 사용하여 원본 메서드를 호출합니다.

**CGLIB 프록시의 특징**

• **클래스 기반 프록시**: 인터페이스가 아닌 클래스 자체를 프록시하므로, 인터페이스 없이도 AOP 적용이 가능합니다.
• **메서드 가로채기**: public 및 protected 메서드를 가로챌 수 있지만, final이나 private 메서드는 오버라이드할 수 없으므로 프록시 대상에서 제외됩니다.
• **성능**: 초기에는 바이트코드 생성으로 인한 오버헤드가 있지만, 생성된 프록시 클래스는 캐싱되므로 이후 호출에서는 성능 저하가 거의 없습니다.

**CGLIB 프록시 사용 시 주의사항**

1. **final 클래스 및 메서드 제한**: final로 선언된 클래스나 메서드는 상속 및 오버라이딩이 불가능하므로 CGLIB 프록시를 적용할 수 없습니다.

2. **생성자 코드 실행**: CGLIB은 서브클래스를 생성하므로 대상 클래스의 기본 생성자가 필요합니다. 만약 기본 생성자가 없다면 프록시 생성 시 예외가 발생할 수 있습니다.

3. **의존성 추가**: CGLIB 라이브러리가 클래스패스에 포함되어 있어야 합니다. Spring 3.2 이상부터는 기본적으로 포함되어 있습니다.

4. **프록시 객체 타입**: 프록시 객체는 대상 클래스의 서브클래스이므로, instanceof 연산자는 예상대로 동작하지만, 직접적인 타입 캐스팅 시 주의해야 합니다.

**CGLIB 프록시의 장단점**

**장점:**

• **인터페이스 없이도 프록시 생성 가능**: 인터페이스를 구현하지 않은 클래스에도 AOP를 적용할 수 있습니다.
• **유연한 AOP 적용**: 클래스의 메서드 전반에 걸쳐 부가 기능을 적용할 수 있습니다.

**단점:**

• **final 제한**: final 클래스나 메서드에는 적용할 수 없습니다.
• **복잡성 증가**: 바이트코드 조작으로 인한 복잡성이 있으며, 디버깅이 어려울 수 있습니다.
• **성능 오버헤드**: 초기 프록시 생성 시 약간의 성능 저하가 있을 수 있습니다.

**예시 코드**

```java
@Service
public class SampleService {
    public void doSomething() {
        // 로직 구현
    }
}
```

  

위와 같은 클래스에 트랜잭션을 적용하고 싶지만, 인터페이스를 구현하지 않았다면 Spring은 CGLIB 프록시를 사용하여 AOP를 적용합니다.

```java
@Transactional
@Service
public class SampleService {
    public void doSomething() {
        // 트랜잭션이 적용된 로직
    }
}
```  


**요약**

CGLIB 프록시는 클래스 상속과 메서드 오버라이딩을 활용하여 원본 객체에 부가 기능을 추가하는 프록시 객체를 생성하는 기술입니다. Spring 프레임워크에서는 AOP를 구현할 때 인터페이스 기반 프록시의 한계를 극복하기 위해 CGLIB 프록시를 사용합니다. 이를 통해 인터페이스를 구현하지 않은 클래스나 메서드에도 효과적으로 AOP를 적용할 수 있습니다.

**5. 다중 어드바이스 적용 시 순서 문제**

**문제점:**

트랜잭션 어드바이스 외에 다른 AOP 어드바이스가 존재하는 경우, 어드바이스의 적용 순서에 따라 트랜잭션 동작이 달라질 수 있습니다.

**해결 방안:**

• **@Order 애노테이션 사용:** 어드바이스의 적용 순서를 명시적으로 지정하여 트랜잭션 어드바이스가 올바른 시점에 적용되도록 합니다.
• **Aspect 순서 관리:** 트랜잭션 관리가 우선적으로 적용되어야 하는지, 이후에 적용되어야 하는지 고려하여 순서를 설정합니다.

**6. 프록시 객체에 대한 이해 부족**

**문제점:**

빈(bean)의 실제 타입이 프록시 객체임을 인지하지 못하고 캐스팅하거나, instanceof 연산자를 사용할 때 예상치 못한 동작이 발생할 수 있습니다.

**해결 방안:**

• **타입 체크 주의:** 프록시 객체의 타입을 직접적으로 체크하거나 캐스팅하는 것을 피합니다.
• **AOP 프레임워크의 동작 방식 이해:** 프록시 패턴과 AOP의 기본 원리를 이해하여 코드를 작성합니다.

**7. 컨텍스트 초기화 순서 문제**

**문제점:**

트랜잭션 관리자가 빈으로 등록되지 않았거나, AOP 설정이 올바르게 되어 있지 않으면 트랜잭션 어드바이스가 적용되지 않습니다.

**해결 방안:**

• **트랜잭션 관리자 확인:** PlatformTransactionManager 타입의 빈이 애플리케이션 컨텍스트에 등록되어 있는지 확인합니다.
• **AOP 설정 확인:** @EnableTransactionManagement 애노테이션이나 <tx:annotation-driven/> 설정을 통해 트랜잭션 어노테이션이 활성화되어 있는지 확인합니다.

**종합적으로**, Spring AOP를 통한 트랜잭션 관리는 편리하지만, 프록시 기반이라는 점과 AOP의 동작 방식을 정확히 이해해야 합니다. 위에서 언급한 문제점들은 대부분 이러한 원리를 이해하고 적용함으로써 해결할 수 있습니다. 또한, 코드 구조를 개선하고, 설정을 정확히 함으로써 안정적인 트랜잭션 관리를 구현할 수 있습니다.

**추가 질문:** _프록시 기반 AOP에서 내부적으로 프록시 객체가 어떻게 생성되고 동작하는지 설명해주세요. 그리고 이러한 프록시 메커니즘이 애플리케이션의 설계에 어떤 영향을 미치는지 논의해주세요._
    
## 4. Spring Boot의 자동 구성(Auto-Configuration) 메커니즘이 내부적으로 어떻게 동작하는지 상세히 설명하고, 특정 자동 구성 클래스를 제외하거나 사용자 정의로 대체하는 방법은 무엇인가요?

**추가 질문:** _Spring Boot에서 조건부 빈 등록(Conditional Bean Registration)이 어떻게 이루어지는지 설명하고, `@Conditional` 애노테이션을 사용하여 커스텀 조건을 정의하는 방법은 무엇인가요?_



## 5. HikariCP 동작방식 


## 6. Isolation Level


## 7. TDD, BDD, ATDD

