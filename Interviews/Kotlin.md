## 1. Kotlin의 coroutine과 Java의 Thread 또는 CompletableFuture를 비교하고, coroutine이 비동기 처리에서 가지는 장점에 대해 설명해보세요. 실제로 프로젝트에서 어떻게 활용했나요?

### **코틀린의 코루틴(Coroutine)과 자바의 스레드(Thread) 또는** CompletableFuture **비교**

#### **1. 코루틴과 스레드의 비교**

• **경량성**: 스레드는 운영체제에서 관리하는 무거운 객체로, 생성과 컨텍스트 스위칭에 많은 비용이 듭니다. 반면 코루틴은 사용자 수준에서 관리되는 경량 스레드로, 수천 개의 코루틴을 생성해도 성능 저하가 적습니다.

• **자원 효율성**: 코루틴은 필요한 자원만 사용하며, 블로킹 없이 비동기 작업을 수행합니다. 이는 스레드 풀의 오버헤드를 줄이고 자원 사용을 최적화합니다.

• **코드 가독성**: 코루틴을 사용하면 비동기 코드를 동기 코드처럼 작성할 수 있어, 복잡한 콜백 구조나 Future의 중첩을 피할 수 있습니다.


####  **2. 코루틴과** CompletableFuture**의 비교**

• **구조적 동시성(Structured Concurrency)**: 코루틴은 부모-자식 관계를 통해 작업의 생명주기를 관리합니다. 부모 코루틴이 취소되면 자식 코루틴도 함께 취소되어 예외 처리가 용이합니다. 반면 CompletableFuture는 이러한 구조를 제공하지 않아 예외 처리와 취소에 대한 추가 관리가 필요합니다.

• **예외 처리 및 취소**: 코루틴은 예외 처리가 언어 수준에서 지원되며, 코루틴 내에서 발생한 예외를 일반적인 try-catch로 처리할 수 있습니다. CompletableFuture는 예외 처리를 위한 별도의 메서드를 사용해야 합니다.

• **가독성 및 유지보수성**: 코루틴은 suspend 함수와 async/await 패턴을 통해 코드의 가독성을 높입니다. CompletableFuture는 람다 표현식과 메서드 체이닝이 복잡해질 수 있습니다.


### **코루틴의** suspend **함수와 비동기 작업의 연결**

• suspend 함수는 코루틴 내에서 일시 중단(suspend)될 수 있는 함수입니다. 이를 통해 비동기 작업을 수행하면서도 코드의 흐름을 중단하지 않고 이어나갈 수 있습니다.

• 예를 들어, 네트워크 요청이나 데이터베이스 접근과 같은 IO 작업을 suspend 함수로 정의하면, 해당 작업이 완료될 때까지 코루틴이 일시 중단되고 다른 코루틴이 실행됩니다.


### **Java의** CompletableFuture**와 코루틴의 성능 차이**

• **성능 및 자원 사용**: 코루틴은 경량 스레드로 동작하여 메모리 소비와 컨텍스트 스위칭 비용이 적습니다. 반면 CompletableFuture는 스레드 풀을 사용하므로 대량의 비동기 작업 시 스레드 풀의 크기와 관리에 따른 오버헤드가 발생할 수 있습니다.

• **확장성**: 코루틴은 더 많은 동시 작업을 효율적으로 처리할 수 있어 고부하 시스템에서 유리합니다.

### **프로젝트에서 코루틴을 활용한 경험**

• **백엔드 서비스 개발**: 대규모 사용자 요청을 처리하는 서버에서 코루틴을 사용하여 비동기 IO 작업을 효율적으로 처리하였습니다.

• **성능 개선**: 코루틴 도입 후 응답 시간이 단축되고 처리량이 증가하였습니다.
• **자원 절약**: 스레드 풀의 크기를 줄이고 메모리 사용량을 최적화하였습니다.
• **코드 유지보수성 향상**: 비동기 로직이 단순화되어 코드의 가독성과 유지보수성이 높아졌습니다.

---


## 2. Kotlin의 null safety와 Java의 Optional을 비교 설명하고, Kotlin의 nullable 처리 방식이 시스템 안정성에 어떻게 기여할 수 있는지 설명해보세요.

### **Kotlin의** null safety**와 Java의** Optional **비교**

#### **1. Kotlin의** null safety

• **Nullable과 Non-null 타입**: Kotlin에서는 타입에 ?를 붙여 nullable 여부를 명시합니다. 예를 들어, String은 null을 허용하지 않지만, String?은 null을 가질 수 있습니다.

• **컴파일 타임 검사**: nullable 타입을 사용하면 컴파일러가 null 가능성을 검사하여 잠재적인 NullPointerException을 방지합니다.

• **null 처리 연산자**:

• **안전 호출 연산자(**?.**)**: 객체가 null이 아닐 때만 접근하여 null 검사를 단순화합니다.
• **엘비스 연산자(**?:**)**: null인 경우 기본값을 제공하여 코드의 간결성을 높입니다.
• **Not-null 단언 연산자(**!!**)**: null이 아님을 단언하지만, null이면 예외가 발생하므로 주의가 필요합니다.

####  **2. Java의** Optional

• **의도한 null 처리**: Optional은 값이 없을 수 있음을 명시적으로 표현하는 컨테이너입니다.
• **메서드 반환 타입**: 주로 반환 타입에 사용하여 null 반환을 피하고자 합니다.
• **한계점**: 필드나 파라미터에는 사용하지 않는 것이 권장되며, null 자체를 완전히 제거하지는 않습니다.

####  **3. 비교 및 시스템 안정성 기여**

• **언어 차원의 지원**: Kotlin은 언어 수준에서 null 안전성을 지원하여 null 관련 오류를 컴파일 타임에 잡을 수 있습니다. Java의 Optional은 라이브러리 수준으로, 완전한 null 안전성을 제공하지는 않습니다.

• **코드 가독성 및 유지보수성**: Kotlin의 null 처리 연산자를 통해 코드가 간결해지고, null 체크 로직이 명확해집니다.

• **안정성 향상**: 컴파일러의 null 검사로 인해 런타임 예외가 줄어들어 시스템의 안정성이 높아집니다.  

###  !! **연산자의 문제점과 Best Practice**

• **문제점**: !! 연산자는 null이 아님을 보장하지만, 실제로 null이면 NullPointerException이 발생합니다. 이는 null 안전성의 이점을 무시하는 것이므로 사용에 주의해야 합니다.

• **Best Practice**: 가능한 한 !! 사용을 피하고, ?., ?:, let, run 등의 안전한 null 처리 방법을 사용합니다.

####  **엘비스 연산자(**?:**)와 Java의** Optional.orElse **비교**

• **엘비스 연산자 사용 예**:

```kotlin
val name: String = nullableName ?: "Unknown"
```

• Optional.orElse **사용 예**:

```java
String name = optionalName.orElse("Unknown");
```


• **비교**: 기능적으로 유사하지만, Kotlin의 엘비스 연산자는 언어 차원에서 지원되어 더 간결하고 사용이 편리합니다.


### **실무에서의 null 처리 전략 및 안정성 기여**

• **버그 예방**: Kotlin으로 마이그레이션하면서 null 관련 버그가 감소하였습니다.
• **개발 효율성 향상**: null 체크 코드가 줄어들고, 컴파일러가 잠재적 오류를 미리 알려주어 개발 속도가 빨라졌습니다.
• **시스템 안정성**: 런타임 예외가 줄어들어 시스템의 신뢰성이 높아졌습니다.

--- 

## 3. Kotlin에서 inline 함수와 reified 타입 파라미터를 사용할 때 컴파일러 수준에서의 구현 차이와 이로 인한 타입 소거(Type Erasure) 문제의 해결 방법은 무엇인가요? 또한, 이를 활용하여 제네릭 함수에서 런타임 타입 검사를 수행하는 방법을 예시와 함께 설명해주세요.

### **타입 소거(Type Erasure)와 문제점**

• **정의**: 제네릭 타입은 컴파일 시점에만 유지되고, 런타임에는 타입 정보가 제거되는 현상입니다.
• **문제점**: 런타임에 제네릭 타입 정보를 사용할 수 없어, 타입 검사나 캐스팅에 제약이 있습니다.

### inline **함수와** reified **타입 파라미터**

#### **1** inline **함수**

• **동작 원리**: 함수 호출 부분에 함수 본문을 인라인으로 대체하여 함수 호출 오버헤드를 제거합니다.
• **장점**: 성능 향상과 함께 람다 파라미터를 사용할 때 클로저 생성 비용을 줄일 수 있습니다.

#### **2.** reified **타입 파라미터**

• **용도**: inline 함수의 타입 파라미터에 reified 키워드를 사용하여, 타입 정보를 런타임까지 유지합니다.
• **장점**: 타입 소거를 우회하여 제네릭 타입에 대한 런타임 처리가 가능해집니다.

  

### **컴파일러 수준에서의 구현 차이**

• **일반 함수**: 제네릭 타입은 컴파일 후 타입 소거로 인해 런타임에 정보가 없습니다.
• inline **+** reified **함수**: 컴파일러가 함수 호출부에 실제 타입을 대입하여 인라인화하므로, 타입 정보가 런타임에 유지됩니다.


**런타임 타입 검사 예시**

```kotlin
inline fun <reified T> Gson.fromJson(json: String): T {
    return this.fromJson(json, T::class.java)
}
```

• **설명**: T::class.java를 사용하여 제네릭 타입 T의 클래스 정보를 얻습니다.
• **활용**: JSON 파싱이나 리플렉션에서 타입 정보를 사용하여 타입 안전성을 확보합니다.

#### crossinline**과** noinline **키워드**

**1.** noinline

• **용도**: inline 함수에서 인라인되지 않을 람다 파라미터에 사용합니다.
• **이점**: 해당 람다를 변수에 저장하거나, 여러 곳에서 호출할 수 있습니다.

```kotlin
inline fun performAction(action: () -> Unit, noinline callback: () -> Unit) {
    action()
    someFunction(callback)
}
```

**2.** crossinline

• **용도**: inline 함수에서 비지역 반환을 허용하지 않도록 람다 파라미터에 사용합니다.
• **이점**: 람다 내에서 return 키워드를 사용할 때 함수 전체가 아닌 람다 블록만 종료되도록 제한합니다.

```kotlin
inline fun performAction(crossinline action: () -> Unit) {
    someFunction { 
        action()
    }
}
```

**함수의 제어 흐름에 대한 영향**

• noinline: 인라인되지 않으므로 함수의 제어 흐름에 영향을 주지 않고, 람다를 전달하거나 저장할 수 있습니다.
• crossinline: 비지역 반환을 막아 예기치 않은 함수 종료를 방지하며, 안전한 제어 흐름을 유지합니다.


--- 

## 4. 코틀린의 코루틴(Coroutine)은 비동기 프로그래밍을 위해 어떻게 설계되었으며, 전통적인 스레드 기반 모델과 어떤 근본적인 차이가 있나요? 코루틴 컨텍스트와 디스패처를 활용하여 백그라운드 작업과 UI 스레드 간의 컨텍스트 전환을 효율적으로 관리하는 방법을 상세히 설명해주세요.

### **코루틴의 설계와 전통적인 스레드 모델과의 차이**

#### **1. 코루틴의 설계**

• **비동기 코드의 동기화**: 코루틴은 비동기 작업을 동기 코드처럼 작성할 수 있게 해줍니다.
• **경량 스레드**: 코루틴은 스레드보다 가볍게 생성 및 관리되며, 수많은 코루틴을 효율적으로 처리합니다.
• **구조화된 동시성**: 작업의 생명주기를 계층적으로 관리하여 예외 처리와 취소를 용이하게 합니다.

#### **2. 전통적인 스레드 기반 모델과의 근본적인 차이**

• **스레드의 무거움**: 스레드는 운영체제에서 관리하며, 생성과 컨텍스트 스위칭에 많은 비용이 듭니다.
• **블로킹 I/O**: 스레드는 블로킹 작업 시 자원을 비효율적으로 사용합니다.
• **코루틴의 비블로킹**: 코루틴은 suspend 함수를 통해 비동기 작업을 비블로킹 방식으로 처리합니다.
• **자원 효율성**: 코루틴은 필요한 시점에만 실행되며, 자원 소비를 최소화합니다.


### **코루틴 컨텍스트와 디스패처를 활용한 컨텍스트 전환 관리**

#### **1. 코루틴 컨텍스트**

• **정의**: 코루틴의 동작을 정의하는 요소들의 집합으로, 디스패처, Job, 예외 핸들러 등을 포함합니다.
• **구성 요소**:
• **디스패처(Dispatcher)**: 코루틴이 실행될 스레드를 결정합니다.
• **Job**: 코루틴의 생명주기를 관리합니다.

#### **2. 디스패처(Dispatcher)**

• Dispatchers.Main: 메인(UI) 스레드에서 코루틴을 실행합니다.
• Dispatchers.IO: IO 작업에 최적화된 스레드 풀에서 실행합니다.
• Dispatchers.Default: CPU 집약적인 작업을 위한 스레드 풀에서 실행합니다.
• **커스텀 디스패처**: 필요에 따라 독자적인 스레드 풀을 정의할 수 있습니다.

#### **3. 컨텍스트 전환 예시**

```kotlin
fun loadData() {
    CoroutineScope(Dispatchers.Main).launch {
        // 메인 스레드에서 시작
        val data = withContext(Dispatchers.IO) {
            // 백그라운드 스레드에서 실행되는 비동기 작업
            fetchDataFromNetwork()
        }
        // 메인 스레드에서 UI 업데이트
        updateUI(data)
    }
}
```

• withContext: 코루틴 내에서 다른 디스패처로 컨텍스트를 전환합니다.
• **효율적인 관리**: 필요한 작업에 적합한 스레드를 사용하여 자원 활용을 최적화합니다.

### **코루틴의 예외 처리와** CoroutineExceptionHandler

#### **1. 예외 처리**

• **코루틴 내 예외**: 코루틴 내부에서 발생한 예외는 상위 코루틴이나 CoroutineScope로 전파됩니다.
• try-catch **사용**: 코루틴 내부에서 일반적인 예외 처리와 동일하게 사용 가능합니다.


```kotlin
launch {
    try {
        // 코루틴 작업
    } catch (e: Exception) {
        // 예외 처리
    }
}
```

**2.** CoroutineExceptionHandler **사용**

• **전역 예외 처리**: 코루틴 스코프에 예외 핸들러를 설정하여 전역적으로 예외를 처리합니다.

```kotlin
val handler = CoroutineExceptionHandler { _, exception ->
    println("예외 발생: $exception")
}

CoroutineScope(Dispatchers.Main + handler).launch {
    // 코루틴 작업
}
```

### **구조화된 동시성이 코루틴의 안정성과 가독성에 기여하는 방법**

• **안정성**: 부모-자식 코루틴의 관계를 통해 작업을 체계적으로 관리하여 예외와 취소 시 일관된 동작을 보장합니다.
• **가독성**: 코드의 흐름이 명확해지고, 비동기 로직을 이해하기 쉽습니다.
• **유지보수성**: 작업의 시작과 종료, 예외 처리가 한 곳에서 관리되어 복잡한 비동기 시스템의 유지보수가 용이합니다.