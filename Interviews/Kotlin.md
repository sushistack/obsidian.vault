## **1. Kotlin의 coroutine과 Java의 Thread 또는 CompletableFuture를 비교하고, coroutine이 비동기 처리에서 가지는 장점에 대해 설명해보세요. 실제로 프로젝트에서 어떻게 활용했나요?**

### **코틀린의 코루틴(Coroutine)과 자바의 스레드(Thread) 또는** CompletableFuture **비교**

#### **1. 코루틴과 스레드의 비교**

• **경량성**: 스레드는 운영체제에서 관리하는 무거운 객체로, 생성과 컨텍스트 스위칭에 많은 비용이 듭니다. 반면 코루틴은 사용자 수준에서 관리되는 경량 스레드로, 수천 개의 코루틴을 생성해도 성능 저하가 적습니다.

• **자원 효율성**: 코루틴은 필요한 자원만 사용하며, 블로킹 없이 비동기 작업을 수행합니다. 이는 스레드 풀의 오버헤드를 줄이고 자원 사용을 최적화합니다.

• **코드 가독성**: 코루틴을 사용하면 비동기 코드를 동기 코드처럼 작성할 수 있어, 복잡한 콜백 구조나 Future의 중첩을 피할 수 있습니다.


####  **2. 코루틴과** CompletableFuture**의 비교**

• **구조적 동시성(Structured Concurrency)**: 코루틴은 부모-자식 관계를 통해 작업의 생명주기를 관리합니다. 부모 코루틴이 취소되면 자식 코루틴도 함께 취소되어 예외 처리가 용이합니다. 반면 CompletableFuture는 이러한 구조를 제공하지 않아 예외 처리와 취소에 대한 추가 관리가 필요합니다.

• **예외 처리 및 취소**: 코루틴은 예외 처리가 언어 수준에서 지원되며, 코루틴 내에서 발생한 예외를 일반적인 try-catch로 처리할 수 있습니다. CompletableFuture는 예외 처리를 위한 별도의 메서드를 사용해야 합니다.

• **가독성 및 유지보수성**: 코루틴은 suspend 함수와 async/await 패턴을 통해 코드의 가독성을 높입니다. CompletableFuture는 람다 표현식과 메서드 체이닝이 복잡해질 수 있습니다.


### **코루틴의** suspend **함수와 비동기 작업의 연결**

• suspend 함수는 코루틴 내에서 일시 중단(suspend)될 수 있는 함수입니다. 이를 통해 비동기 작업을 수행하면서도 코드의 흐름을 중단하지 않고 이어나갈 수 있습니다.

• 예를 들어, 네트워크 요청이나 데이터베이스 접근과 같은 IO 작업을 suspend 함수로 정의하면, 해당 작업이 완료될 때까지 코루틴이 일시 중단되고 다른 코루틴이 실행됩니다.


### **Java의** CompletableFuture**와 코루틴의 성능 차이**

• **성능 및 자원 사용**: 코루틴은 경량 스레드로 동작하여 메모리 소비와 컨텍스트 스위칭 비용이 적습니다. 반면 CompletableFuture는 스레드 풀을 사용하므로 대량의 비동기 작업 시 스레드 풀의 크기와 관리에 따른 오버헤드가 발생할 수 있습니다.

• **확장성**: 코루틴은 더 많은 동시 작업을 효율적으로 처리할 수 있어 고부하 시스템에서 유리합니다.

### **프로젝트에서 코루틴을 활용한 경험**

• **백엔드 서비스 개발**: 대규모 사용자 요청을 처리하는 서버에서 코루틴을 사용하여 비동기 IO 작업을 효율적으로 처리하였습니다.

• **성능 개선**: 코루틴 도입 후 응답 시간이 단축되고 처리량이 증가하였습니다.
• **자원 절약**: 스레드 풀의 크기를 줄이고 메모리 사용량을 최적화하였습니다.
• **코드 유지보수성 향상**: 비동기 로직이 단순화되어 코드의 가독성과 유지보수성이 높아졌습니다.

---


## **2. Kotlin의 null safety와 Java의 Optional을 비교 설명하고, Kotlin의 nullable 처리 방식이 시스템 안정성에 어떻게 기여할 수 있는지 설명해보세요.**

### **Kotlin의** null safety**와 Java의** Optional **비교**

#### **1. Kotlin의** null safety

• **Nullable과 Non-null 타입**: Kotlin에서는 타입에 ?를 붙여 nullable 여부를 명시합니다. 예를 들어, String은 null을 허용하지 않지만, String?은 null을 가질 수 있습니다.

• **컴파일 타임 검사**: nullable 타입을 사용하면 컴파일러가 null 가능성을 검사하여 잠재적인 NullPointerException을 방지합니다.

• **null 처리 연산자**:

• **안전 호출 연산자(**?.**)**: 객체가 null이 아닐 때만 접근하여 null 검사를 단순화합니다.

• **엘비스 연산자(**?:**)**: null인 경우 기본값을 제공하여 코드의 간결성을 높입니다.

• **Not-null 단언 연산자(**!!**)**: null이 아님을 단언하지만, null이면 예외가 발생하므로 주의가 필요합니다.


####  **2. Java의** Optional

• **의도한 null 처리**: Optional은 값이 없을 수 있음을 명시적으로 표현하는 컨테이너입니다.

• **메서드 반환 타입**: 주로 반환 타입에 사용하여 null 반환을 피하고자 합니다.

• **한계점**: 필드나 파라미터에는 사용하지 않는 것이 권장되며, null 자체를 완전히 제거하지는 않습니다.

####  **3. 비교 및 시스템 안정성 기여**

• **언어 차원의 지원**: Kotlin은 언어 수준에서 null 안전성을 지원하여 null 관련 오류를 컴파일 타임에 잡을 수 있습니다. Java의 Optional은 라이브러리 수준으로, 완전한 null 안전성을 제공하지는 않습니다.

• **코드 가독성 및 유지보수성**: Kotlin의 null 처리 연산자를 통해 코드가 간결해지고, null 체크 로직이 명확해집니다.

• **안정성 향상**: 컴파일러의 null 검사로 인해 런타임 예외가 줄어들어 시스템의 안정성이 높아집니다.  

###  !! **연산자의 문제점과 Best Practice**

• **문제점**: !! 연산자는 null이 아님을 보장하지만, 실제로 null이면 NullPointerException이 발생합니다. 이는 null 안전성의 이점을 무시하는 것이므로 사용에 주의해야 합니다.

• **Best Practice**: 가능한 한 !! 사용을 피하고, ?., ?:, let, run 등의 안전한 null 처리 방법을 사용합니다.

####  **엘비스 연산자(**?:**)와 Java의** Optional.orElse **비교**

• **엘비스 연산자 사용 예**:

```kotlin
val name: String = nullableName ?: "Unknown"
```

• Optional.orElse **사용 예**:

```java
String name = optionalName.orElse("Unknown");
```


• **비교**: 기능적으로 유사하지만, Kotlin의 엘비스 연산자는 언어 차원에서 지원되어 더 간결하고 사용이 편리합니다.


### **실무에서의 null 처리 전략 및 안정성 기여**

• **버그 예방**: Kotlin으로 마이그레이션하면서 null 관련 버그가 감소하였습니다.
• **개발 효율성 향상**: null 체크 코드가 줄어들고, 컴파일러가 잠재적 오류를 미리 알려주어 개발 속도가 빨라졌습니다.
• **시스템 안정성**: 런타임 예외가 줄어들어 시스템의 신뢰성이 높아졌습니다.

--- 

## 3. Kotlin에서 `inline` 함수와 `reified` 타입 파라미터를 사용할 때 컴파일러 수준에서의 구현 차이와 이로 인한 타입 소거(Type Erasure) 문제의 해결 방법은 무엇인가요? 또한, 이를 활용하여 제네릭 함수에서 런타임 타입 검사를 수행하는 방법을 예시와 함께 설명해주세요.

**추가 질문:** _`crossinline`과 `noinline` 키워드의 역할은 무엇이며, `inline` 함수에서 이들을 어떻게 활용할 수 있는지 상세히 설명해주세요. 이 키워드들이 함수의 제어 흐름에 어떤 영향을 미치는지도 논의해주세요._

## 4. 코틀린의 코루틴(Coroutine)은 비동기 프로그래밍을 위해 어떻게 설계되었으며, 전통적인 스레드 기반 모델과 어떤 근본적인 차이가 있나요? 코루틴 컨텍스트와 디스패처를 활용하여 백그라운드 작업과 UI 스레드 간의 컨텍스트 전환을 효율적으로 관리하는 방법을 상세히 설명해주세요.

**추가 질문:** _코루틴의 예외 처리는 어떻게 이루어지며, `CoroutineExceptionHandler`를 사용하여 전역 예외를 처리하는 방법은 무엇인가요? 또한, 구조화된 동시성(Structured Concurrency)이 코루틴의 안정성과 가독성에 어떻게 기여하는지 설명해주세요._

