
이번 실습에서는 람다 함수의 **메모리(Memory)**, **타임아웃(Timeout)**, 그리고 **실행 컨텍스트(Execution Context)**를 활용한 성능 최적화 방법을 직접 체험해 보겠습니다. 이 세 가지 요소는 람다 함수의 성능과 비용에 직접적인 영향을 미칩니다.

---

## 1. 메모리 및 vCPU 설정

람다 함수의 **`General configuration`**에서 메모리 크기를 조정할 수 있습니다. 128MB부터 10,240MB(10GB)까지 설정 가능합니다.

- **메모리와 CPU 관계:** 람다에서 CPU 코어 수를 직접 설정할 수는 없습니다. 대신 메모리를 늘리면 비례하여 CPU 자원이 더 많이 할당됩니다.
    
- **비용과 성능:** 메모리 크기는 함수 실행 비용에 직접적인 영향을 미칩니다. 함수에 필요한 만큼의 메모리를 정확하게 설정하는 것이 중요합니다. 메모리가 부족하면 성능 저하가 발생하고, 너무 많으면 불필요한 비용이 발생합니다.

---

## 2. 타임아웃(Timeout) 조정 ⏰

타임아웃은 함수가 실행될 수 있는 최대 시간을 정의합니다.

- **기본값:** 3초
    
- **최대값:** 900초 (15분)

### 실습 과정

1. **3초 타임아웃 설정:** 람다 함수의 타임아웃을 3초로 설정합니다.
    
2. **`time.sleep(2)` 코드 삽입:** 함수 코드에 2초 동안 대기하는 코드를 추가합니다. 함수를 실행하면 2초 후 성공적으로 `prod` 값을 반환합니다.
    
3. **`time.sleep(5)`로 변경:** 코드를 5초 동안 대기하도록 수정합니다. 함수를 실행하면 **`Task timed out after 3.00 seconds`**라는 오류가 발생합니다.
    
4. **타임아웃 조정:** 이제 타임아웃을 6초로 늘립니다. 함수를 다시 실행하면 5초 후 성공적으로 완료됩니다.

이 실습을 통해 타임아웃 설정이 함수의 성공 여부에 얼마나 중요한 영향을 미치는지 알 수 있습니다. 타임아웃을 너무 길게 설정하면 함수가 무한 루프에 빠지거나 예상치 못한 오류로 인해 불필요하게 오랜 시간 실행될 위험이 있습니다.

---

## 3. 실행 컨텍스트 재사용 최적화 🚀

람다 함수는 **실행 컨텍스트**를 재사용하여 함수 초기화 시간을 줄입니다. 이를 활용하여 성능을 크게 향상시킬 수 있습니다.

### 실습 과정

1. **비효율적인 코드:** 핸들러 함수 내부에 `time.sleep(3)`을 포함하는 `connect_to_db()` 함수를 호출하는 코드를 작성합니다.

```Python
import time

def lambda_handler(event, context):
	# 매번 호출될 때마다 3초 대기 (데이터베이스 연결 시뮬레이션)
	time.sleep(3) 
	return "prod"
```
이 함수를 호출할 때마다 매번 3초의 지연이 발생합니다.

2. **최적화된 코드:** `connect_to_db()` 함수 호출을 **핸들러 함수 외부**로 이동시킵니다.

```Python
import time

# 핸들러 외부에 위치하여 초기화 시에만 실행
print("Initializing...")
time.sleep(3) 

def lambda_handler(event, context):
	print("Handler is running...")
	return "prod"
```
    
3. **결과 확인:**
    
    - **첫 번째 호출:** `INIT DURATION`이 약 3,000ms로 표시됩니다. 이는 **콜드 스타트**로 인해 초기화 코드가 실행되었기 때문입니다.
        
    - **두 번째 호출부터:** `INIT DURATION`은 사라지고, `Duration`이 1ms 미만으로 급격히 짧아집니다. 이는 람다가 이전에 생성된 실행 컨텍스트를 재사용하여 초기화 과정을 건너뛰었기 때문입니다.

이처럼 데이터베이스 연결, 라이브러리 로딩 등 초기화 시간이 오래 걸리는 작업은 핸들러 외부에 배치하여 함수 성능을 극대화할 수 있습니다.