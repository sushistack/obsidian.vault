

람다 함수의 성능과 구성은 여러 핵심 요소에 의해 좌우됩니다. 이 요소들을 이해하면 서버리스 애플리케이션을 속도와 비용 효율성 측면에서 모두 최적화할 수 있습니다.

---

## 1. 메모리 및 vCPU 설정

람다 함수는 **RAM(메모리)** 설정을 통해 성능을 제어합니다.

- **메모리 크기:** 메모리는 **128MB**부터 **10GB**까지 1MB 단위로 조정할 수 있습니다.
    
- **vCPU 할당:** 람다는 메모리 크기에 비례하여 **vCPU 자원**을 할당합니다. 즉, 메모리를 늘리면 자동으로 CPU 성능이 향상됩니다.
    
    - **1,792MB** 메모리를 할당하면 **1개의 vCPU**를 온전히 사용할 수 있습니다.
        
    - 1,792MB를 초과하면 여러 vCPU를 활용할 수 있으며, 이 경우 멀티스레딩과 같은 병렬 처리 기법을 사용하면 성능 향상 효과를 극대화할 수 있습니다.
        
- **성능 최적화:** CPU 집약적인 작업(예: 복잡한 계산, 데이터 압축)의 경우, 메모리를 늘려 실행 시간을 단축하고 비용을 절감할 수 있습니다.

---

## 2. 타임아웃(Timeout) 설정

**타임아웃**은 람다 함수가 실행될 수 있는 최대 시간을 정의합니다.

- **기본값:** 3초
    
- **최대값:** 900초 (15분)
    
- **활용:** 람다 함수는 **15분 이내**에 완료될 수 있는 작업에 가장 적합합니다. 15분 이상 걸리는 장기 실행 작업은 AWS Fargate, ECS, 또는 EC2와 같은 다른 컴퓨팅 서비스 사용을 고려해야 합니다.

---

## 3. 실행 컨텍스트(Execution Context)와 콜드 스타트 🧊

람다 함수는 **실행 컨텍스트**를 재사용하여 **콜드 스타트(Cold Start)** 지연을 줄이고 성능을 개선합니다. 실행 컨텍스트는 코드가 실행되는 임시 런타임 환경으로, 외부 종속성(예: 데이터베이스 연결)을 초기화하는 역할을 합니다.

### 💡 최적화 원칙

초기화에 시간이 오래 걸리는 작업은 핸들러 함수 **외부**에 배치하여, 실행 컨텍스트가 재사용될 때마다 다시 초기화되는 것을 방지해야 합니다.

**비효율적인 코드 (Bad Practice)**

```Python
import os

def handler(event, context):
    db_client = database.connect(os.getenv('DB_URL')) # 매번 호출 시 연결
    user = db_client.get_user(event['user_id'])
    return user
```

이 코드는 함수가 호출될 때마다 데이터베이스에 새로 연결하므로 비효율적입니다.

**최적화된 코드 (Best Practice)**

```Python
import os

db_client = database.connect(os.getenv('DB_URL')) # 핸들러 외부에 연결

def handler(event, context):
    # 재사용 가능한 클라이언트를 사용
    user = db_client.get_user(event['user_id']) 
    return user
```

이 코드는 데이터베이스 연결을 한 번만 초기화하고, 이후 호출에서 이 연결을 재사용합니다. 이를 통해 함수 실행 시간을 크게 단축할 수 있습니다.

---

## 4. 임시 저장소: /tmp 디렉터리 💾

람다 함수는 **`/tmp`** 디렉터리에 최대 **10GB**의 임시 저장 공간을 제공합니다.

- **용도:** 큰 파일을 다운로드하거나, 작업 중 생성되는 중간 파일을 저장하는 용도로 사용됩니다.
    
- **특징:** 실행 컨텍스트가 재사용되는 동안 `/tmp`에 저장된 파일은 계속 존재할 수 있으므로, 여러 호출에 걸쳐 데이터를 공유할 수 있습니다.
    
- **영구 저장소:** `/tmp`는 임시 저장소이므로, 데이터의 영구 보관이 필요한 경우 S3와 같은 영구 저장소에 파일을 저장해야 합니다.