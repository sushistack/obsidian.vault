
람다 함수는 들어오는 요청에 따라 자동으로 확장(scale)되지만, 이는 동시 실행(concurrent executions) 한도 내에서 이루어집니다. 람다의 **동시성(Concurrency)**은 특정 시점에 함수가 동시에 처리할 수 있는 요청 수를 의미하며, 이 개념을 이해하는 것은 애플리케이션의 안정성과 성능을 보장하는 데 매우 중요합니다.

---

## 1. 동시성 및 스로틀링

![[Pasted image 20250831213419.png]]

AWS 계정에는 리전별로 기본적으로 **1,000개의 동시성 한도**가 있으며, 이 한도는 모든 람다 함수가 공유합니다. 트래픽이 급증하여 이 한도를 초과하는 요청이 발생하면, 람다는 이를 **스로틀링(Throttling)**합니다.

- **동기 호출:** 스로틀링된 요청은 **`429` 오류**를 즉시 반환합니다.
    
- **비동기 호출:** 스로틀링된 요청은 람다의 내부 이벤트 큐에 들어갑니다. 람다는 **최대 6시간** 동안 **지수 백오프(Exponential Backoff)** 전략에 따라 자동으로 재시도를 수행하여 결국 성공적으로 처리될 수 있도록 합니다.

## 2. 예약된 동시성 (Reserved Concurrency)

**예약된 동시성**은 특정 람다 함수가 사용할 수 있는 최대 동시 실행 수를 **제한**하는 기능입니다. 이 기능을 사용하면 하나의 함수가 계정의 모든 동시성 한도를 독점하는 것을 방지할 수 있습니다.

- **설정 이유:** 트래픽이 급증하는 함수가 다른 중요한 함수(예: API Gateway를 사용하는 함수)의 동시성을 모두 소모하여 스로틀링을 유발하는 상황을 막을 수 있습니다.
    
- **작동 방식:** 함수에 예약된 동시성 값을 `50`으로 설정하면, 이 함수는 최대 50개의 요청만 동시에 처리할 수 있으며, 초과하는 요청은 스로틀링됩니다. 이는 다른 함수들이 나머지 동시성 한도를 사용할 수 있게 보장합니다.

---

## 3. 콜드 스타트(Cold Starts)와 프로비저닝된 동시성

**콜드 스타트(Cold Start)**는 람다 함수가 일정 시간 사용되지 않아 인스턴스가 종료된 후, 다음 호출 시 새로운 인스턴스를 시작하고 코드를 초기화하는 데 걸리는 시간을 의미합니다. 이 초기화 시간(예: 코드 로딩, DB 연결)은 첫 번째 요청의 지연 시간을 증가시켜 사용자 경험에 부정적인 영향을 줄 수 있습니다.

**프로비저닝된 동시성(Provisioned Concurrency)**은 이러한 콜드 스타트 문제를 해결하기 위한 기능입니다.

- **작동 방식:** 함수가 호출되기 전에 특정 수의 람다 인스턴스를 미리 준비 상태로 유지합니다.
    
- **장점:** 모든 요청이 미리 준비된 인스턴스에서 처리되므로, 콜드 스타트가 발생하지 않아 **예측 가능한 낮은 지연 시간**을 보장합니다.
    
- **활용:** 응답 시간이 중요한 애플리케이션(예: API Gateway를 통한 실시간 사용자 요청 처리)에 유용하며, Application Auto Scaling을 사용하여 트래픽 패턴에 맞춰 프로비저닝된 동시성 수를 조절할 수 있습니다.
    

---

## 4. 비동기 호출과 재시도 🔄

S3 이벤트와 같이 비동기적으로 람다 함수를 호출할 때, 만약 동시성 한도 초과로 인해 스로틀링이 발생하면 람다는 이벤트를 내부 큐에 반환합니다. 람다는 이벤트를 **최대 6시간** 동안 지수 백오프 전략에 따라 재시도합니다.

- **재시도 간격:** 처음에는 1초 간격으로 시작하여 최대 5분 간격까지 지수적으로 늘어납니다.
    
- **목적:** 함수가 처리할 수 있는 용량이 확보될 때까지 이벤트를 안전하게 재처리하여 데이터 손실을 방지합니다.

이러한 동시성, 스로틀링, 예약된 동시성, 그리고 콜드 스타트 개념을 이해하고 적절히 관리하면 람다 기반의 서버리스 애플리케이션을 더욱 안정적이고 효율적으로 운영할 수 있습니다.