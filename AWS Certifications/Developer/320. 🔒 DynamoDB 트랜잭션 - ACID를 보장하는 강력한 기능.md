
DynamoDB **트랜잭션(Transactions)**은 여러 아이템 또는 테이블에 걸쳐 **"전부 아니면 전무(All-or-nothing)"** 원칙을 적용하는 기능입니다. 이 기능은 여러 개의 읽기 또는 쓰기 작업이 하나의 논리적 단위로 묶여, 모든 작업이 성공하거나 혹은 하나라도 실패할 경우 전체가 롤백(rollback)되는 것을 보장합니다. 이는 분산 데이터베이스 환경에서 데이터의 **ACID(원자성, 일관성, 고립성, 지속성)** 속성을 제공하여 데이터 무결성을 유지하는 데 필수적입니다.

---

## 🔬 트랜잭션의 기본 개념

### **ACID 속성**

DynamoDB 트랜잭션은 데이터베이스의 ACID 속성을 보장합니다.

- **원자성(Atomicity)**: 트랜잭션 내의 모든 작업은 하나의 단위로 간주되어, 전부 성공하거나 전부 실패합니다.
    
- **일관성(Consistency)**: 트랜잭션이 성공적으로 완료되면 데이터베이스는 항상 유효한 상태를 유지합니다.
    
- **고립성(Isolation)**: 여러 트랜잭션이 동시에 실행되더라도, 각 트랜잭션은 독립적으로 실행되는 것처럼 보입니다.
    
- **지속성(Durability)**: 성공적으로 커밋된 트랜잭션의 결과는 시스템 장애가 발생하더라도 영구적으로 보존됩니다.
    

### **트랜잭션 모드**

DynamoDB에서 트랜잭션은 읽기(Read)와 쓰기(Write) 두 가지 모드로 나뉩니다.

![[Pasted image 20250906194941.png]]

#### 1. **읽기 모드(Read Modes)**

- **결과적 일관성(Eventual Consistency)**: 가장 빠른 읽기 모드. 읽기 작업이 완료된 후에도 데이터가 변경될 수 있음.
    
- **강력한 일관성(Strong Consistency)**: 가장 최근에 완료된 쓰기 작업의 결과를 즉시 반영.
    
- **트랜잭션 일관성(Transactional Consistency)**: 여러 테이블의 여러 아이템을 동시에 읽을 때, 해당 시점의 일관된 스냅샷(snapshot)을 제공.
    

#### 2. **쓰기 모드(Write Modes)**

- **표준(Standard)**: 여러 쓰기 작업 중 일부만 성공할 수 있음.
    
- **트랜잭션(Transactional)**: 여러 테이블에 대한 여러 쓰기 작업이 전부 성공하거나, 전부 실패함. 금융 거래와 같이 데이터의 일관성이 매우 중요한 경우에 사용.
    

---

## ✍️ 트랜잭션 API와 비용

DynamoDB 트랜잭션은 별도의 API를 통해 수행되며, 표준 작업에 비해 더 많은 용량을 소모합니다.

### **API 종류**

- **`TransactGetItems`**: 하나 이상의 `GetItem` 작업을 하나의 트랜잭션으로 묶어, 여러 아이템을 트랜잭션 일관성 있게 읽습니다.
    
- **`TransactWriteItems`**: 하나 이상의 `PutItem`, `UpdateItem`, `DeleteItem` 작업을 하나의 트랜잭션으로 묶어, 여러 아이템을 트랜잭션적으로 씁니다.
    

### **용량 단위(RCU/WCU) 계산**

트랜잭션 작업은 백그라운드에서 **준비(prepare)** 및 **커밋(commit)**의 두 단계로 이루어지므로, 일반적인 읽기/쓰기 작업보다 **두 배**의 용량을 소모합니다.

#### **예시: 쓰기 용량(WCU) 계산**

- **상황**: 초당 3건의 트랜잭션 쓰기 작업이 필요하고, 아이템 크기는 5KB입니다.
    
- **계산**: `(초당 트랜잭션 수) × (아이템 크기 / WCU 단위) × 2`
    
    - `WCU = 3 × (5KB / 1KB) × 2`
        
    - `WCU = 3 × 5 × 2 = 30 WCU`
        

#### **예시: 읽기 용량(RCU) 계산**

- **상황**: 초당 5건의 트랜잭션 읽기 작업이 필요하고, 아이템 크기는 5KB입니다.
    
- **계산**: `(초당 트랜잭션 수) × (아이템 크기 / RCU 단위) × 2`
    
    - 5KB는 `4KB`의 RCU 단위로 올림 되므로, 2단위의 RCU가 소모됩니다. (5KB / 4KB) = 1.25 -> 올림하여 2.
        
    - `RCU = 5 × 2 × 2`
        
    - `RCU = 20 RCU`
        

---

## 🏦 활용 사례: 금융 거래

트랜잭션의 가장 대표적인 사용 사례는 바로 **금융 거래**입니다. 두 개의 테이블을 사용해 송금 및 거래 내역을 관리하는 시나리오를 생각해 봅시다.

|테이블|속성|
|---|---|
|`AccountBalance`|`account_id`(PK), `balance`, `last_transaction_timestamp`|
|`BankTransactions`|`transaction_id`(PK), `transaction_timestamp`, `from_account`, `to_account`, `amount`|

**시나리오**: A 계좌에서 B 계좌로 일정 금액을 송금하는 상황

1. **`TransactWriteItems` 호출**: 애플리케이션은 하나의 트랜잭션으로 다음 두 가지 작업을 동시에 수행합니다.
    
    - `UpdateItem`: A 계좌의 잔액을 감소시킵니다.
        
    - `UpdateItem`: B 계좌의 잔액을 증가시킵니다.
        
    - `PutItem`: `BankTransactions` 테이블에 거래 내역을 추가합니다.
        
2. **전부 아니면 전무**:
    
    - 모든 작업이 성공하면 트랜잭션이 커밋되어 두 계좌의 잔액이 모두 변경되고 거래 내역이 기록됩니다.
        
    - 만약 A 계좌의 잔액을 업데이트하는 데 실패하면, B 계좌의 잔액 증가 및 거래 내역 추가 작업도 자동으로 롤백되어 아무 작업도 반영되지 않습니다.
        

이러한 `TransactWriteItems`의 강력한 원자성은 두 계좌의 잔액이 일치하지 않는 데이터 불일치 상태를 방지하여 금융 시스템의 신뢰성을 보장합니다.

---

## 📌 핵심 요약

- **용도**: 여러 아이템에 대한 올-오어-낫싱 작업을 수행하여 데이터 무결성 보장.
    
- **ACID**: 원자성, 일관성, 고립성, 지속성 속성을 제공.
    
- **API**: `TransactGetItems` (읽기), `TransactWriteItems` (쓰기).
    
- **비용**: 일반 작업에 비해 **2배의 용량 단위** 소모.
    
- **활용**: 금융 거래, 게임 점수 관리, 주문 시스템 등 높은 데이터 일관성이 요구되는 모든 애플리케이션.
    

DynamoDB 트랜잭션은 단일 아이템 작업을 넘어서는 복잡한 데이터 관리 시나리오에서 매우 중요한 역할을 합니다. 특히 분산 시스템에서 데이터 일관성을 유지하기 위한 가장 효과적인 방법 중 하나입니다.