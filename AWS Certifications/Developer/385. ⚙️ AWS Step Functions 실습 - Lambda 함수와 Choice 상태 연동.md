
이번 실습에서는 AWS Step Functions와 AWS Lambda를 연동하여 간단한 워크플로우를 구축하고 실행하는 과정을 상세히 살펴봅니다. Lambda 함수의 결과에 따라 워크플로우의 흐름을 제어하는 **Choice 상태**의 동작 방식을 직접 확인해 보겠습니다.

---

## 1. 🚀 Lambda 함수 생성 및 코드 작성

가장 먼저 워크플로우의 첫 번째 단계에서 실행될 Lambda 함수를 생성합니다.

1. AWS Lambda 콘솔에서 **'함수 생성(Create function)'**을 클릭합니다.
    
2. **'처음부터 작성(Author from scratch)'**을 선택하고, 함수 이름을 `HelloFunction`으로 지정합니다.
    
3. 런타임은 **Node.js** 최신 버전을 선택합니다.
    
4. 함수 생성 후, 아래의 코드를 `index.js` 파일에 붙여넣고 **'Deploy'**를 클릭하여 변경사항을 배포합니다.
    

이 함수는 입력 페이로드의 `who` 키를 읽어 `Hello, [who]!` 형태의 문자열을 반환합니다.

```JavaScript
exports.handler = async (event) => {
    const who = event.who;
    const message = `Hello, ${who}!`;
    console.log(message);
    return message;
};
```

5. **테스트 이벤트(Test event)**를 생성하여 함수가 올바르게 작동하는지 확인합니다. 아래 JSON을 입력하고 테스트를 실행하면 `Hello, John!`이라는 응답을 볼 수 있습니다.


```JSON
{
  "who": "John"
}
```

이제 이 함수의 **ARN(Amazon Resource Name)**을 복사해 둡니다. 이는 Step Functions에서 이 함수를 호출할 때 사용됩니다.

---

## 2. 📝 State Machine 정의

이제 Lambda 함수를 포함하는 상태 머신(state machine)을 정의할 차례입니다.

1. AWS Step Functions 콘솔에서 **'상태 머신 생성(Create state machine)'**을 클릭합니다.
    
2. **'빈 상태 머신(Start with a blank workflow)'**을 선택하고, '디자이너(Designer)' 탭에서 **'코드(Code)'** 탭으로 전환합니다.
    
3. 아래의 JSON 코드를 붙여넣습니다. `LambdaInvoke` 상태의 `Resource` 부분에 위에서 복사한 Lambda 함수의 ARN을 붙여넣어야 합니다.
    

이 워크플로우는 `LambdaInvoke`를 실행한 후, 반환된 결과에 따라 `Is Teacher` 또는 `Not Teacher` 상태로 분기합니다.

```JSON
{
  "Comment": "A simple state machine that demonstrates invoking a Lambda function and a choice state.",
  "StartAt": "LambdaInvoke",
  "States": {
    "LambdaInvoke": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Parameters": {
        "FunctionName": "arn:aws:lambda:us-east-1:123456789012:function:HelloFunction",
        "Payload": {
          "who.$": "$.who"
        }
      },
      "Next": "ChoiceState"
    },
    "ChoiceState": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.Payload",
          "StringEquals": "Hello, Stephane Maarek!",
          "Next": "IsTeacher"
        }
      ],
      "Default": "NotTeacher"
    },
    "IsTeacher": {
      "Type": "Pass",
      "Result": "Woohoo! The teacher is Stephane Maarek!",
      "End": true
    },
    "NotTeacher": {
      "Type": "Fail",
      "Error": "NotFound",
      "Cause": "Stephane the teacher wasn't found in the output of the Lambda Function."
    }
  }
}
```

4. **'다음(Next)'**을 클릭하여 워크플로우를 시각적으로 확인합니다. 올바르게 설정되었다면, **LambdaInvoke -> ChoiceState**로 이어지고, ChoiceState에서 두 갈래로 나뉘는 그래프가 보입니다.
    
5. **'생성(Create)'**을 클릭하여 상태 머신을 만듭니다. Step Functions가 Lambda를 호출할 수 있도록 자동으로 실행 역할(Execution Role)이 생성됩니다.
    

---

## 3. 🏃‍♂️ 실행 및 결과 확인

이제 생성된 상태 머신을 실행하여 결과를 확인해 보겠습니다.

### ✅ 성공적인 실행: 'Stephane' 입력

1. **'실행 시작(Start execution)'**을 클릭합니다.
    
2. 입력 페이로드에 아래 JSON을 입력합니다.


```JSON
{
  "who": "Stephane Maarek"
}
```

3. 실행이 완료되면 그래프에서 **LambdaInvoke**와 **IsTeacher**가 녹색으로 표시되는 것을 볼 수 있습니다.
    

|단계 이름|입력(Input)|출력(Output)|설명|
|---|---|---|---|
|**`LambdaInvoke`**|`{"who": "Stephane Maarek"}`|`"Hello, Stephane Maarek!"`|Lambda 함수가 실행되어 "Hello, Stephane Maarek!"을 반환합니다.|
|**`ChoiceState`**|`"Hello, Stephane Maarek!"`|`"Hello, Stephane Maarek!"`|반환된 문자열이 "Hello, Stephane Maarek!"과 일치하므로 `IsTeacher`로 분기합니다.|
|**`IsTeacher`**|`"Hello, Stephane Maarek!"`|`"Woohoo! The teacher is Stephane Maarek!"`|`Pass` 상태가 정의된 문자열을 출력하고 워크플로우가 성공적으로 종료됩니다.|

### ❌ 실패하는 실행: 'John' 입력

1. **'새로운 실행(New execution)'**을 클릭합니다.
    
2. 입력 페이로드에 아래 JSON을 입력합니다.


```JSON
{
  "who": "John Doe"
}
```

3. 실행이 완료되면 그래프에서 **`NotTeacher`** 상태가 빨간색으로 표시되며 실패한 것을 볼 수 있습니다.

|단계 이름|입력(Input)|출력(Output)|설명|
|---|---|---|---|
|**`LambdaInvoke`**|`{"who": "John Doe"}`|`"Hello, John Doe!"`|Lambda 함수가 실행되어 "Hello, John Doe!"을 반환합니다.|
|**`ChoiceState`**|`"Hello, John Doe!"`|`"Hello, John Doe!"`|반환된 문자열이 "Hello, Stephane Maarek!"과 일치하지 않으므로 `Default` 분기인 `NotTeacher`로 이동합니다.|
|**`NotTeacher`**|`"Hello, John Doe!"`|(실패)|`Fail` 상태에 정의된 오류 메시지와 함께 워크플로우가 종료됩니다.|

이 실습을 통해 Step Functions가 Lambda 함수의 실행 결과를 읽고, 조건에 따라 워크플로우의 흐름을 유연하게 제어할 수 있음을 확인했습니다. 이는 복잡한 비즈니스 로직을 시각화하고 관리하는 데 큰 도움이 됩니다.