
이번 문서에서는 Elastic Load Balancer (ELB)의 중요한 기능 중 하나인 **스티키 세션(Sticky Sessions)**, 또는 **세션 선호도(Session Affinity)**에 대해 자세히 알아보겠습니다. 이 기능은 특정 클라이언트의 요청이 항상 동일한 백엔드 인스턴스로 전달되도록 보장합니다.

---
### 스티키 세션이란 무엇인가?

![[Pasted image 20250627154251.png]]

일반적으로 로드 밸런서는 들어오는 모든 요청을 여러 백엔드 인스턴스에 균등하게 분산시킵니다. 그러나 스티키 세션이 활성화되면, **동일한 클라이언트로부터 오는 연속적인 요청은 항상 동일한 백엔드 인스턴스로 전달**됩니다.

**작동 예시:**

애플리케이션 로드 밸런서(ALB) 뒤에 2개의 EC2 인스턴스가 있고 3명의 클라이언트가 있다고 가정해 봅시다.

| **클라이언트** | **첫 번째 요청 대상** | **두 번째 이후 요청 대상** |
| --------- | -------------- | ----------------- |
| 클라이언트 1   | EC2 인스턴스 1     | EC2 인스턴스 1        |
| 클라이언트 2   | EC2 인스턴스 2     | EC2 인스턴스 2        |
| 클라이언트 3   | EC2 인스턴스 1     | EC2 인스턴스 1        |

클라이언트 1이 첫 요청을 EC2 인스턴스 1로 보냈다면, 이후의 모든 요청도 EC2 인스턴스 1로 전달됩니다. 이는 로드 밸런서가 모든 요청을 분산하는 일반적인 동작과는 다릅니다.

**적용 가능한 로드 밸런서:**

#### 타겟 그룹 > 속성 변경

![[Pasted image 20250627155059.png]]

스티키 세션은 Classic Load Balancer (CLB), Application Load Balancer (ALB), Network Load Balancer (NLB) 모두에서 활성화할 수 있습니다.

---

### 스티키 세션의 작동 원리 (쿠키 사용)

스티키 세션은 주로 **쿠키(Cookie)**를 사용하여 구현됩니다.

1. **쿠키 생성 및 전송:** 클라이언트가 로드 밸런서에 첫 요청을 보내면, 로드 밸런서(또는 백엔드 애플리케이션)는 해당 클라이언트를 특정 백엔드 인스턴스에 매핑하는 정보를 담은 쿠키를 생성하여 클라이언트에게 응답과 함께 보냅니다.

2. **쿠키 저장:** 클라이언트(웹 브라우저)는 이 쿠키를 저장합니다.

3. **후속 요청 시 쿠키 포함:** 클라이언트가 동일한 로드 밸런서에 두 번째 이후 요청을 보낼 때, 저장된 쿠키를 요청 헤더에 포함하여 보냅니다.

4. **동일 인스턴스로 라우팅:** 로드 밸런서는 요청에 포함된 쿠키를 읽고, 그 쿠키 정보에 따라 해당 클라이언트의 요청을 이전에 연결되었던 동일한 백엔드 인스턴스로 전달합니다.

5. **만료일:** 쿠키에는 만료일이 설정되어 있으며, 만료되면 클라이언트는 다른 인스턴스로 리디렉션될 수 있습니다.

---

### 스티키 세션의 사용 사례 및 고려 사항

#### 사용 사례 (Use Case):

가장 일반적인 사용 사례는 **사용자 세션 데이터의 손실 방지**입니다. 예를 들어, 사용자의 로그인 정보, 장바구니 내용, 세션 상태 등의 중요한 데이터가 특정 백엔드 인스턴스의 메모리에 저장되어 있는 경우 (세션 불일치), 스티키 세션이 없으면 사용자의 다음 요청이 다른 인스턴스로 전달되어 해당 데이터가 유실될 수 있습니다. 스티키 세션은 이러한 문제를 방지하여 원활한 사용자 경험을 제공합니다.

#### 고려 사항: 부하 불균형 (Load Imbalance)

스티키 세션을 활성화하면 **백엔드 인스턴스 간의 부하 불균형**이 발생할 수 있습니다. 예를 들어, 특정 '스티키' 사용자(많은 요청을 보내는 사용자)가 특정 인스턴스에 고정되면, 해당 인스턴스에만 부하가 집중될 수 있습니다. 이는 로드 밸런싱의 원래 목적인 부하 분산에 역행할 수 있으므로, 사용 시 신중하게 고려해야 합니다.

---

### 스티키 세션 쿠키의 종류

스티키 세션에는 두 가지 주요 쿠키 유형이 있습니다.

#### 1. 애플리케이션 기반 쿠키 (Application-based Cookie)

- **생성 주체:** **대상(Target)**, 즉 백엔드 애플리케이션 자체에서 생성하는 사용자 정의 쿠키입니다.
- **특징:**
    - 애플리케이션이 요구하는 사용자 정의 속성을 포함할 수 있습니다.
    - 쿠키 이름은 각 대상 그룹마다 개별적으로 지정해야 합니다.
    - `AWSALB`, `AWSALBAPPOR`, `AWSALBTG`와 같이 ELB 자체에서 사용하는 예약된 쿠키 이름은 사용할 수 없습니다.
    - ALB에서 이 유형의 애플리케이션 쿠키를 사용하는 경우, 로드 밸런서 자체에서 쿠키를 생성하며, 이 쿠키의 이름은 `AWSALBAPP`이 됩니다. (설명에 약간의 모호성이 있을 수 있으나, 보통은 애플리케이션이 생성한 쿠키를 로드 밸런서가 인식하는 방식, 또는 로드 밸런서가 애플리케이션을 위해 생성하는 방식 두 가지로 볼 수 있습니다.)
- **만료:** 애플리케이션 자체에서 쿠키의 만료 기간을 지정할 수 있습니다.

#### 2. 기간 기반 쿠키 (Duration-based Cookie)

- **생성 주체:** **로드 밸런서 자체**에서 생성하는 쿠키입니다.
- **쿠키 이름:**
    - ALB의 경우 `AWSALB`
    - CLB의 경우 `AWSELB`
- **만료:** 로드 밸런서 설정에서 지정한 특정 기간(예: 1초에서 7일)에 따라 만료됩니다.

---

### 스티키 세션 활성화 및 동작 확인 (ALB 예시)

ALB에서 스티키 세션을 활성화하는 과정은 대상 그룹(Target Group) 수준에서 이루어집니다.

1. **대상 그룹 선택:** AWS 콘솔에서 해당 대상 그룹을 선택합니다.
2. **속성 편집:** "작업(Actions)" 메뉴에서 "속성 편집(Edit attributes)"을 선택합니다.
3. **스티키니스 설정:** "Stickiness" 섹션에서 기능을 활성화하고 다음 중 하나를 선택합니다.
    - **로드 밸런서 생성 쿠키 (Load balancer generated cookie):** 기간 기반 쿠키를 사용하며, 만료 기간(예: 1일)을 설정합니다.
    - **애플리케이션 기반 쿠키 (Application-based cookie):** 애플리케이션에서 생성하는 쿠키를 사용하며, 해당 쿠키의 이름을 지정합니다 (예: `MYCUSTOMCOOKIEAPP`).
4. **변경 사항 저장:** 설정을 저장합니다.

**브라우저 개발자 도구를 통한 동작 확인:**

스티키 세션이 활성화된 후 웹 브라우저의 개발자 도구(Web Developer Tools)를 열고 네트워크 탭에서 요청/응답을 확인하면 다음과 같은 쿠키를 볼 수 있습니다.

- **응답 쿠키 (Response Cookie):** 로드 밸런서가 클라이언트에게 보내는 응답 헤더에 `Set-Cookie` 필드를 통해 스티키 세션 쿠키(`AWSALB` 또는 사용자 정의 쿠키)가 포함됩니다. 여기에는 만료일, 경로, 값이 명시됩니다.
- **요청 쿠키 (Request Cookie):** 클라이언트가 후속 요청을 보낼 때, 브라우저가 저장된 쿠키를 `Cookie` 헤더에 포함하여 로드 밸런서로 다시 전송합니다. 로드 밸런서는 이 쿠키를 기반으로 트래픽을 동일한 인스턴스로 라우팅합니다.

이러한 쿠키의 주고받음을 통해 스티키 세션이 실제로 어떻게 작동하는지 확인할 수 있습니다.

---

**참고:** 쿠키 이름이나 세부 사항을 모두 암기할 필요는 없지만, **애플리케이션 기반 쿠키**와 **기간 기반 쿠키**라는 두 가지 유형이 있으며, 클라이언트 세션의 연속성을 보장하기 위해 사용된다는 점을 이해하는 것이 중요합니다. 이 개념은 CloudFront와 같은 다른 AWS 서비스에서도 유사하게 적용될 수 있습니다.


### 매번 키 값을 통해 계산하여 라우팅하는 것인가? 

아닙니다, 매번 계산하는 것이 아니라 **저장하고 활용**하는 방식에 가깝습니다.

정확히는, 로드 밸런서가 **클라이언트에게 발급한 쿠키에 특정 키 값(식별자)**을 담아서 보내고, 클라이언트가 그 쿠키를 보관했다가 **재요청 시 다시 로드 밸런서에게 그 키 값을 보내주는 방식**입니다.

로드 밸런서는 이 키 값을 받아서 내부적으로 관리하는 **'세션 테이블' 또는 '매핑 정보'**를 찾아 해당 클라이언트가 이전에 연결되었던 백엔드 인스턴스를 식별합니다.

---

### 작동 흐름 상세 설명

1. **최초 요청:**
    
    - 클라이언트 → 로드 밸런서
    - 로드 밸런서는 부하 분산 알고리즘(예: 최소 연결 수)에 따라 최적의 백엔드 인스턴스 (예: EC2-A)를 선택합니다.
    - **로드 밸런서는 EC2-A에 대한 식별 정보가 담긴 쿠키를 생성합니다.**
    - 로드 밸런서 → 클라이언트 (응답과 함께 쿠키 전송)
    - 클라이언트 브라우저는 이 쿠키를 저장합니다.
2. **후속 요청:**
    
    - 클라이언트 → 로드 밸런서 (저장했던 쿠키를 요청 헤더에 포함하여 전송)
    - **로드 밸런서는 요청에 포함된 쿠키를 읽어 그 키 값(식별자)을 확인합니다.** 이 키 값은 로드 밸런서가 "아, 이 클라이언트는 이전에 EC2-A에 연결되었던 클라이언트구나!"라고 인식할 수 있는 정보입니다.
    - 로드 밸런서는 이 키 값에 따라, 부하 상태와 무관하게 **이전과 동일한 인스턴스 (EC2-A)로 트래픽을 라우팅**합니다.

---

### '계산'이 아닌 '저장 및 조회'

- **매번 계산?**: 만약 매번 로드 밸런서가 클라이언트 정보를 보고 어떤 인스턴스에 고정할지를 "계산"해야 한다면, 이는 상당한 오버헤드를 유발하고 스티키 세션의 목적(동일 인스턴스 유지)을 달성하기 어렵게 만들 것입니다.
- **저장 및 조회**: 로드 밸런서는 클라이언트와 인스턴스 간의 매핑 정보를 쿠키에 암호화하여 저장하고, 클라이언트로부터 이 쿠키를 받을 때 해당 키 값을 '조회'하여 이전에 매핑된 인스턴스를 찾아냅니다. 내부적으로는 로드 밸런서가 클라이언트 IP 주소, 쿠키 값과 백엔드 인스턴스 간의 매핑 테이블을 유지할 수도 있습니다.

따라서, 키 값은 매번 계산되는 것이 아니라, 로드 밸런서가 한 번 발급한 후 클라이언트와 로드 밸런서 간에 주고받으면서 **저장된 정보로서 활용**되고, 로드 밸런서는 이 정보를 **조회**하여 라우팅 결정을 내리는 것입니다.


### 매핑 테이블의 크기는? 

네, 정확한 지적이십니다. 스티키 세션(Sticky Sessions)을 구현하기 위한 **매핑 테이블의 크기가 커질 수 있다는 점은 로드 밸런서 설계 및 운영 시 중요한 고려 사항**입니다.

---

### 매핑 테이블 크기 증가의 원인과 영향

1. **동시 활성 세션 수 증가:**
    
    - 웹 사이트나 애플리케이션의 동시 접속자 수가 많아질수록, 로드 밸런서가 관리해야 할 클라이언트-인스턴스 매핑의 수가 비례하여 증가합니다. 각 클라이언트의 세션이 고정되어야 하므로, 해당 클라이언트의 고유한 식별자와 연결된 백엔드 인스턴스 정보가 테이블에 저장되어야 합니다.
    - 수십만, 수백만 명의 사용자가 동시에 접속하는 대규모 서비스의 경우, 이 매핑 테이블은 엄청난 크기로 불어날 수 있습니다.

2. **세션 만료 시간:**
    
    - 스티키 세션 쿠키의 만료 시간이 길수록, 해당 세션 정보가 매핑 테이블에 더 오래 유지됩니다. 만료 시간이 짧으면 유휴 세션 정보가 더 빨리 제거되어 테이블 크기를 관리하는 데 도움이 되지만, 사용자 경험 측면에서는 세션이 끊길 위험이 있습니다.

3. **로드 밸런서의 리소스 사용:**
    
    - 매핑 테이블이 커지면 로드. 밸런서의 **메모리 사용량**이 증가합니다.
    - 또한, 새로운 요청이 올 때마다 이 거대한 테이블에서 해당 클라이언트의 매핑 정보를 **검색하고 업데이트하는 데 더 많은 CPU 리소스와 시간이 소요**될 수 있습니다. 이는 로드 밸런서의 **성능 저하(지연 시간 증가)**로 이어질 수 있습니다.

4. **확장성 문제 (Scale Out):**
    
    - 로드 밸런서 자체도 내부적으로 확장되어야 하는데, 이 매핑 테이블을 여러 로드 밸런서 노드 간에 **동기화하거나 분산하는 복잡성**이 발생할 수 있습니다. 일관성을 유지하면서 고성능으로 매핑 정보를 조회하는 것은 쉽지 않은 일입니다.

---

### AWS ELB와 관리형 서비스의 장점

이러한 문제점들 때문에, 직접 로드 밸런서를 구축하여 스티키 세션을 구현하는 것은 매우 까다롭고 확장성 문제가 발생하기 쉽습니다.

하지만 **AWS의 Elastic Load Balancer (ELB)와 같은 관리형 서비스**는 이러한 복잡성을 개발자 대신 AWS가 처리해 줍니다.

- **자동 확장:** AWS는 ELB 인스턴스의 내부 스케일링을 자동으로 관리하여, 매핑 테이블의 크기 증가로 인한 성능 문제를 최소화합니다. 사용량이 증가하면 AWS가 내부적으로 더 많은 로드 밸런서 노드를 추가하거나 기존 노드의 용량을 늘려 처리합니다.

- **고가용성 및 내구성:** 매핑 정보를 여러 가용 영역(AZ)에 걸쳐 복제하거나 내구성을 갖춘 방식으로 저장하여, 단일 로드 밸런서 노드에 장애가 발생하더라도 세션 정보가 유실되지 않도록 합니다.

- **최적화된 구현:** AWS는 로드 밸런싱 및 세션 관리를 위한 고도로 최적화된 내부 알고리즘과 데이터 구조를 사용하므로, 대규모 환경에서도 효율적으로 작동합니다.

결론적으로, 스티키 세션의 매핑 테이블 크기 증가는 잠재적인 성능 및 관리 부담을 야기할 수 있는 중요한 문제입니다. 하지만 AWS ELB와 같은 관리형 서비스는 이러한 복잡한 문제를 AWS가 대신 해결해주므로, 사용자는 매핑 테이블의 물리적인 크기나 관리에 대해 크게 신경 쓸 필요 없이 스티키 세션 기능을 활용할 수 있습니다.