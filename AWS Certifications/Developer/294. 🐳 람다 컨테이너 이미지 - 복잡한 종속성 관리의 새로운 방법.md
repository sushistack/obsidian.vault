

**람다 컨테이너 이미지**는 2020년 말에 출시된 기능으로, 람다 함수를 컨테이너 이미지 형태로 배포할 수 있게 합니다. 이 기능은 최대 **10GB** 크기의 이미지를 지원하여, 기존 람다 함수의 용량 제한(250MB)을 크게 확장하고 복잡한 종속성을 쉽게 관리할 수 있는 새로운 워크플로우를 제공합니다.

---

## 1. 람다 컨테이너 이미지의 기본 원리

![[Pasted image 20250831214153.png]]

람다 컨테이너 이미지는 표준 Docker 이미지처럼 보이지만, 한 가지 핵심적인 조건이 있습니다. 바로 **람다 런타임 API(Lambda Runtime API)**를 구현하는 **베이스 이미지** 위에 빌드되어야 한다는 점입니다.

- **동작 방식:**
    
    1. 개발자가 AWS가 제공하는 **람다 베이스 이미지**를 사용합니다. 이 베이스 이미지에는 람다 런타임 API가 이미 포함되어 있습니다.
        
    2. 이 이미지 위에 애플리케이션 코드와 종속성을 추가합니다.
        
    3. 최종 컨테이너 이미지를 빌드하여 **Amazon ECR(Elastic Container Registry)**에 푸시합니다.
        
    4. 람다 함수는 ECR에서 이 이미지를 가져와 실행합니다.
        
- **장점:** 복잡한 빌드 과정(예: 네이티브 라이브러리 컴파일)을 컨테이너 내에서 처리하므로, 람다 레이어 없이도 대규모 종속성을 쉽게 관리할 수 있습니다. 또한 **Lambda Runtime Interface Emulator**를 사용하여 컨테이너를 로컬 환경에서 테스트할 수 있어 개발 워크플로우가 간소화됩니다.
    

---

## 2. Dockerfile 예시 (Node.js)

다음은 AWS가 제공하는 베이스 이미지를 사용하여 람다 컨테이너 이미지를 빌드하는 간단한 `Dockerfile` 예시입니다.

```Dockerfile
# 1. 람다 런타임 API가 포함된 AWS 베이스 이미지 사용
FROM public.ecr.aws/lambda/nodejs:18

# 2. 애플리케이션 코드 복사
COPY app.js package.json ./

# 3. 종속성 설치
RUN npm install

# 4. 람다 핸들러 함수 지정
CMD [ "app.lambdaHandler" ]
```

---

## 3. 컨테이너 이미지 최적화 모범 사례

최적화된 람다 컨테이너 이미지는 콜드 스타트 지연 시간을 줄이고 실행 성능을 높이는 데 중요합니다.

|모범 사례|설명|
|---|---|
|**AWS 제공 베이스 이미지 사용**|AWS가 제공하는 베이스 이미지(Amazon Linux 2 기반)는 람다 서비스에 캐시되어 있어, 컨테이너를 더 빠르게 시작할 수 있습니다.|
|**멀티스테이지 빌드(Multi-stage Builds)**|빌드 단계와 최종 이미지 단계를 분리하여 최종 이미지에 필요한 아티팩트(artifacts)만 포함시킵니다. 이를 통해 이미지 크기를 대폭 줄일 수 있습니다.|
|**계층화(Layering) 최적화**|Docker 이미지 레이어의 순서를 최적화합니다. 변경이 거의 없는 레이어(예: OS, 런타임)를 먼저 배치하고, 자주 변경되는 레이어(예: 코드)를 나중에 배치하여 빌드 및 배포 속도를 높입니다.|
|**단일 리포지토리 활용**|대규모 종속성(레이어)을 포함하는 함수들을 단일 ECR 리포지토리에 저장하면, 중복되는 레이어를 효율적으로 관리하고 스토리지 비용을 절감할 수 있습니다.|

### 주요 사용 사례

- **대규모 종속성:** 최대 10GB에 이르는 대용량 라이브러리(머신러닝 모델, 데이터 처리 패키지 등)를 포함해야 할 때 유용합니다.
    
- **통합된 배포 워크플로우:** AWS ECS/Fargate와 람다를 모두 사용하는 팀의 경우, 컨테이너 이미지를 통해 통일된 배포 파이프라인을 구축할 수 있습니다.
    
- **복잡한 빌드 프로세스:** 복잡한 빌드 스크립트나 네이티브 컴파일이 필요한 경우, 컨테이너 내에서 모든 빌드 작업을 완료한 후 최종 이미지만 배포할 수 있습니다.