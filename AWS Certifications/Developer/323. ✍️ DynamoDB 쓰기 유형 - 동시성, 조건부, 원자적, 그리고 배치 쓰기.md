
DynamoDB는 다양한 쓰기(Write) 작업을 지원하며, 각각의 유형은 특정 시나리오에 맞는 데이터 무결성 및 동시성 문제를 해결하기 위해 설계되었습니다. 이번 아티클에서는 DynamoDB에서 사용 가능한 네 가지 주요 쓰기 유형에 대해 상세히 알아보겠습니다.

![[Pasted image 20250906195300.png]]

---

## 🏎️ 동시 쓰기 (Concurrent Writes)

동시 쓰기는 여러 사용자가 동시에 같은 아이템을 수정하려고 할 때 발생하는 기본 동작입니다. 이 경우, DynamoDB는 단순히 **가장 최근에 들어온 요청을 처리**합니다.

- **동작 방식**: 여러 쓰기 요청이 동시에 들어오면, 먼저 도착한 요청이 처리되고, 이후에 도착한 요청이 그 결과를 덮어씁니다.
    
- **문제점**: 두 사용자 모두 쓰기 작업이 성공했다고 응답을 받지만, 실제로는 한 사용자의 변경 사항만 최종적으로 반영됩니다. 이로 인해 **데이터 손실**이 발생할 수 있습니다.
    

예시:

두 명의 사용자가 동시에 item의 value를 업데이트하려고 합니다.

1. 사용자 A: `value`를 `1`로 업데이트
    
2. 사용자 B: value를 2로 업데이트
    
    결과: B의 요청이 A의 요청보다 나중에 처리될 경우, 최종 value는 2가 됩니다. 사용자 A는 자신의 업데이트가 성공했다고 생각하지만 실제로는 덮어쓰여진 것입니다.

---

## 🚦 조건부 쓰기 (Conditional Writes)

조건부 쓰기는 동시성 문제를 해결하기 위한 중요한 방법입니다. 이 기능은 특정 조건이 만족될 때만 쓰기 작업을 수행하도록 보장합니다. 이를 **낙관적 잠금(Optimistic Locking)**이라고도 부릅니다.

- **동작 방식**: 쓰기 요청에 조건을 포함시켜, DynamoDB가 해당 조건을 확인한 후 쓰기 작업을 실행합니다. 조건이 거짓이면 요청은 실패합니다.
    
- **해결책**: 다른 사용자의 변경 사항을 덮어쓰는 것을 방지하고, 데이터의 **정합성**을 보장합니다.
    

예시:

위와 동일한 상황에서, 조건부 쓰기를 사용합니다.

1. 사용자 A: "현재 `value`가 `0`일 경우에만 `value`를 `1`로 업데이트하라."
    
2. 사용자 B: "현재 value가 0일 경우에만 value를 2로 업데이트하라."
    
    결과: 사용자 A의 요청이 먼저 도착하여 value를 1로 성공적으로 업데이트합니다. 이후 사용자 B의 요청이 도착하면, 조건(value가 0인지)이 이미 충족되지 않으므로 요청은 실패합니다. 사용자 B는 실패 응답을 받고, A의 변경 사항은 안전하게 유지됩니다.

---

## ➕ 원자적 쓰기 (Atomic Writes)

원자적 쓰기는 기존 값을 읽고, 수정하고, 다시 쓰는 일련의 과정을 하나의 원자적인 단위로 수행하는 작업입니다. 이는 덮어쓰기 없이 값을 **증가시키거나 감소시키는** 데 사용됩니다.

- **동작 방식**: 여러 사용자가 동시에 같은 아이템의 값을 변경하려고 해도, 모든 요청이 성공적으로 처리됩니다.
    
- **용도**: 카운터, 득점 시스템 등 **절대 덮어쓰면 안 되는** 값을 업데이트할 때 사용됩니다.
    

예시:

두 명의 사용자가 투표 카운터를 증가시키려고 합니다.

1. 사용자 A: "현재 값에 `1`을 더하라."
    
2. 사용자 B: "현재 값에 2를 더하라."
    
    결과: 두 요청은 모두 성공하며, 최종 값은 (원래 값) + 1 + 2가 됩니다.
    

> 💡 **주의**: 원자적 카운터 작업은 조건부 쓰기처럼 덮어쓰기를 방지하지만, 조건 확인 없이 단순히 값만 업데이트한다는 점에서 다릅니다.

---

## 📝 배치 쓰기 (Batch Writes)

배치 쓰기는 여러 아이템에 대한 쓰기 작업을 하나의 요청으로 묶어서 효율적으로 처리하는 방법입니다.

- **동작 방식**: `BatchWriteItem` API를 사용하여 여러 `PutItem` 또는 `DeleteItem` 요청을 하나의 API 호출로 보냅니다.
    
- **장점**:
    
    - **네트워크 오버헤드 감소**: 여러 아이템을 한 번에 전송하여 네트워크 요청 횟수를 줄입니다.
        
    - **쓰기 용량 효율성**: 작은 아이템을 여러 개 쓸 때 용량을 더 효율적으로 사용할 수 있습니다.
        
- **주의**: 배치 쓰기는 원자성이 보장되지 않습니다. 즉, 배치 요청 내의 일부 작업만 성공할 수 있습니다. 트랜잭션이 필요한 경우에는 `TransactWriteItems`를 사용해야 합니다.
    

---

## 📊 요약 테이블

|유형|설명|주요 용도|해결하는 문제|
|---|---|---|---|
|**동시 쓰기**|여러 쓰기 요청 중 가장 최근 요청이 덮어씀|기본 동작|데이터 손실 가능성|
|**조건부 쓰기**|특정 조건이 만족할 때만 쓰기 작업 수행|데이터 정합성 보장, 낙관적 잠금|동시성으로 인한 데이터 손실|
|**원자적 쓰기**|덧셈, 뺄셈 등 원자적 연산 수행|카운터, 투표 수 등 증가/감소 작업|읽기-수정-쓰기 과정의 불일치|
|**배치 쓰기**|여러 아이템을 하나의 요청으로 묶어 처리|대량 데이터 일괄 삽입/삭제|네트워크 오버헤드 감소, 효율성 증대|