
캐싱은 애플리케이션 성능을 최적화하고 데이터베이스 부하를 줄이는 데 필수적입니다. 하지만 캐싱을 올바르게 구현하는 것은 복잡할 수 있습니다. 이 가이드에서는 주요 캐싱 전략과 함께 고려해야 할 사항들을 자세히 설명합니다.

---

### 1. 캐싱 구현 전 고려사항 🤔

데이터 캐싱을 시작하기 전에 몇 가지 중요한 질문을 스스로에게 던져야 합니다.

- **데이터 캐싱의 안전성**: 캐시된 데이터가 최신이 아닐 수 있다는 점을 이해해야 합니다 (결과적 일관성). 모든 데이터셋이 캐싱에 적합한 것은 아닙니다. 예를 들어, 매우 민감하거나 항상 최신 상태여야 하는 데이터(예: 은행 잔고)는 캐싱에 부적합할 수 있습니다.

- **캐싱의 효과성**:
    - **효과적인 경우**: <mark class="hltr-red">데이터가 천천히 변경되고, 자주 필요한 키가 소수인 경우 캐싱이 매우 효과적</mark>입니다.
    - **비효과적인 경우(안티 패턴)**: 데이터가 매우 빠르게 변경되고, 데이터셋의 모든 키 공간이 필요한 경우 캐싱이 비효과적일 수 있습니다.

- **데이터 구조의 적합성**: 캐싱은 최적화를 위한 것이므로, <mark class="hltr-red">데이터가 캐싱을 위해 올바르게 구조화되어 있는지 확인</mark>해야 합니다. 예를 들어, <mark class="hltr-red">키-값 쌍이나 집계(aggregation) 결과를 저장</mark>하는 데 캐시가 매우 유용합니다.

- **가장 적절한 캐싱 디자인 패턴**: 어떤 캐싱 전략이 애플리케이션의 특정 요구사항에 가장 적합한지 파악하는 것이 중요합니다.

---

### 2. 주요 캐싱 디자인 패턴 🔄

AWS 시험에서는 주로 두 가지 핵심 캐싱 디자인 패턴에 대한 이해를 요구합니다.

#### 2.1 Lazy Loading (Cache-Aside 또는 Lazy Population)

![[Pasted image 20250720210345.png]]

- **개념**: 애플리케이션이 데이터를 요청할 때, 먼저 캐시를 확인하고 데이터가 없으면 데이터베이스에서 가져와 캐시에 저장하는 방식입니다. "요청 시 로드" 또는 "지연 로드"의 개념입니다.
    
- **작동 방식**:
    1. **애플리케이션**이 데이터를 요청합니다.
    2. 먼저 ElastiCache (Redis/Memcached)에 데이터를 요청합니다.
    3. **캐시 히트(Cache Hit)**: 캐시에 데이터가 있으면 즉시 반환하여 데이터베이스 접근을 건너뜁니다.
    4. **캐시 미스(Cache Miss)**: 캐시에 데이터가 없으면, RDS 데이터베이스에서 데이터를 읽어옵니다.
    5. 읽어온 데이터를 ElastiCache에 다시 기록합니다.
    6. 데이터를 애플리케이션으로 반환합니다.

- **장점**:
    - **효율성**: 실제로 <mark class="hltr-red">요청된 데이터만 캐시에 저장</mark>되므로 매우 효율적입니다.
    - **내결함성**: 캐시가 지워지거나 노드에 장애가 발생해도 치명적이지 않습니다. 캐시가 "워밍업"되는 동안 일시적으로 지연이 증가할 수 있지만, 데이터는 데이터베이스에 안전하게 보존됩니다.

- **단점**:
    - **읽기 지연(Read Penalty)**: 캐시 미스가 발생하면, 캐시 조회 → 데이터베이스 조회 → 캐시 기록이라는 <mark class="hltr-red">여러 번의 네트워크 호출이 발생</mark>하여 초기 읽기 시 지연 시간이 늘어날 수 있습니다. 이는 사용자 경험에 부정적인 영향을 줄 수 있습니다.

    - **오래된 데이터(Stale Data)**: 데이터베이스에서 데이터가 업데이트되더라도 <mark class="hltr-red">캐시의 데이터는 자동으로 업데이트되지 않습</mark>니다. 따라서 캐시에 **오래된 데이터**가 남아있을 수 있으며, 이는 <mark class="hltr-red">결과적 일관성(eventual consistency)을 허용하는 시나리오에만 적합</mark>합니다.
        
- **Python Pseudo-Code 예시**:

```python
def get_user(user_id):
	# 1. 캐시에서 사용자 데이터 조회 (Cache.get)
	record = cache.get(user_id)

	# 2. 캐시 미스인 경우 (record is None)
	if record is None:
		# 3. 데이터베이스에서 사용자 데이터 조회 (db.query)
		record = db.query(f"SELECT * FROM users WHERE id = {user_id}")
		# 4. 조회된 데이터를 캐시에 저장 (Cache.set)
		cache.set(user_id, record)
	# 5. 캐시 히트이거나 데이터베이스에서 가져온 경우, 데이터 반환
	return record

# 사용 예시
user = get_user(17)
```

#### 2.2 Write Through

![[Pasted image 20250720210433.png]]

- **개념**: 데이터베이스에 데이터를 쓰거나 업데이트할 때, 동시에 캐시에도 데이터를 쓰거나 업데이트하는 방식입니다.
    
- **작동 방식**:
    1. **애플리케이션**이 데이터를 업데이트/생성 요청을 합니다.
    2. **ElastiCache**에 데이터를 기록합니다. (이때 캐시는 즉시 업데이트됩니다.)
    3. **RDS 데이터베이스**에도 동일한 데이터를 기록합니다.
    4. 애플리케이션에 성공적으로 기록되었음을 반환합니다.

- **장점**:
    - **데이터 정합성**: <mark class="hltr-red">캐시의 데이터는 항상 데이터베이스의 최신 데이터와 일치</mark>합니다. 캐시에 **오래된 데이터가 없습니다**.

    - **사용자 경험**: 쓰기 작업은 읽기보다 시간이 더 걸릴 것이라고 사용자가 예상하는 경우가 많으므로, 쓰기 작업 시 추가적인 지연이 발생하더라도 사용자 경험에 미치는 영향이 적을 수 있습니다.
        
- **단점**:
    - **쓰기 지연(Write Penalty)**: 한 번의 쓰기 작업에 캐시와 데이터베이스 두 곳에 모두 기록해야 하므로, <mark class="hltr-red">두 번의 네트워크 호출이 발생</mark>하여 쓰기 작업의 지연 시간이 증가합니다.

    - **누락된 데이터(Missing Data)**: 데이터가 데이터베이스에 기록되기 전까지는 캐시에 존재하지 않을 수 있습니다. 모든 데이터가 캐시에 저장 되는 것을 보장하지는 않습니다. (Lazy Loading과 결합하여 이 단점을 보완할 수 있습니다.)

    - **캐시 처닝(Cache Churn)**: 데이터가 데이터베이스에 기록될 때마다 캐시에도 기록되지만, 이 데이터가 실제로 읽히지 않을 수도 있습니다.1 이는 캐시 공간을 비효율적으로 사용하게 만들 수 있습니다 (특히 캐시가 작은 경우).

- **Python Pseudo-Code 예시**:

```python
def save_user(user_id, user_data):
	# 1. 데이터베이스에 사용자 데이터 업데이트 (db.query)
	record = db.query(f"UPDATE users SET data='{user_data}' WHERE id = {user_id}")
	# 2. 캐시에 사용자 데이터 저장 (Cache.set)
	cache.set(user_id, record)
	# 3. 데이터 반환
	return record

# 사용 예시
save_user(17, {"name": "new_name"})
    ```

### 3. 캐시 Eviction (데이터 제거) 및 TTL (Time-to-Live) 🗑️

캐시는 크기가 제한되어 있으므로, 캐시에 저장된 데이터를 관리하고 제거하는 전략이 필요합니다.

- **캐시 Eviction (데이터 제거)**:
    - **명시적 삭제**: 캐시에서 특정 항목을 직접 삭제하는 경우.
    - **메모리 부족**: 캐시 메모리가 가득 찼을 때, 가장 오래되거나 가장 적게 사용된 항목을 제거합니다. (예: **LRU - Least Recently Used**, 가장 최근에 사용되지 않은 항목 제거).

- **TTL (Time-to-Live)**:
    - **개념**: 캐시 항목에 **유효 기간**을 설정하는 것입니다. 이 기간이 지나면 캐시에서 해당 항목을 자동으로 제거합니다.
    - **활용**: 리더보드, 댓글, 활동 스트림 등 다양한 유형의 데이터에 유용하게 적용될 수 있습니다.
    - **기간 설정**: 애플리케이션 요구사항에 따라 몇 초에서 몇 시간 또는 며칠까지 다양하게 설정할 수 있습니다. 매우 자주 요청되는 데이터의 경우, 짧은 TTL도 캐싱 효과를 극대화할 수 있습니다.
    - **목적**: 캐시 메모리를 효율적으로 사용하고, 캐시의 데이터가 지나치게 오래되지 않도록 **데이터 신선도와 캐시 공간 활용 사이의 균형**을 맞춥니다.
- **Eviction 과다 발생 시**: 캐시 메모리가 항상 가득 차서 Eviction이 너무 자주 발생한다면, 캐시 클러스터의 **크기를 확장(스케일 업 또는 스케일 아웃)**하여 더 많은 메모리를 확보하는 것을 고려해야 합니다.

### 4. 캐싱 구현을 위한 조언 💡

캐싱은 강력하지만, 구현하기 어려운 영역입니다.

- **Lazy Loading / Cache-Aside**: 읽기 성능 향상을 위한 **기본적인 전략**으로, 구현이 쉽고 많은 상황에서 효과적입니다. 대부분의 애플리케이션에 적용하는 것을 권장합니다.

- **Write Through**: Lazy Loading 위에 추가적으로 고려할 수 있는 **최적화 전략**입니다. 데이터 신선도가 매우 중요하고, 쓰기 지연을 감수할 수 있는 경우에만 적용하는 것이 좋습니다. 처음부터 Write Through를 우선시하기보다는, Lazy Loading을 먼저 구현하고 필요에 따라 고려하세요.

- **TTL 활용**: Write Through 전략을 사용하지 않는 한, 대부분의 경우 TTL을 설정하는 것이 좋습니다. 애플리케이션의 특성에 맞는 적절한 TTL 값을 설정하세요.

- **의미 있는 데이터만 캐싱**: 모든 데이터를 캐싱할 필요는 없습니다. 사용자 프로필, 블로그 게시물과 같이 자주 읽히고 변경 빈도가 낮은 데이터가 캐싱에 적합합니다. 가격 데이터나 은행 계좌 잔액과 같이 실시간 정확성이 중요한 데이터는 캐싱에 부적합할 수 있습니다.


"컴퓨터 과학에는 두 가지 어려운 문제가 있다: **캐시 무효화(Cache Invalidation)**와 이름 짓기(Naming things)." 이 말은 캐싱이 그만큼 복잡하고 어려운 분야임을 시사합니다. 하지만 AWS 시험에서는 캐싱 전략의 기본 개념과 그 영향에 대한 이해를 요구하므로, 위에서 설명된 내용을 잘 숙지하는 것이 중요합니다.
