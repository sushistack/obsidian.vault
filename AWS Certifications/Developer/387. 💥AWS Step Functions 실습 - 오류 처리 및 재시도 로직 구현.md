
이 글에서는 AWS Step Functions를 사용하여 Lambda 함수에서 발생하는 오류를 효과적으로 처리하는 방법을 실습합니다. **Retry(재시도)**와 **Catch(포착)** 메커니즘을 구현하여 다양한 유형의 오류에 대응하는 워크플로우를 구축해 보겠습니다.

---

## 1. 📝 오류를 발생시키는 Lambda 함수 생성

먼저, 오류를 의도적으로 발생시키는 Lambda 함수를 생성합니다. Step Functions의 오류 처리 기능을 테스트하기 위한 준비 과정입니다.

1. AWS Lambda 콘솔에서 **'함수 생성(Create function)'**을 클릭합니다.
    
2. **'청사진 사용(Use a blueprint)'**을 선택하고, `step-functions-error`를 검색하여 선택합니다. 이 청사진은 `CustomError`라는 이름의 예외를 발생시키는 코드를 포함하고 있습니다.
    
3. 함수 이름을 `MyLambdaFunctionThatFails`로 지정하고, 새 IAM 역할을 생성합니다.
    
4. 함수가 생성되면, 테스트 이벤트를 통해 함수가 **`CustomError`**를 반환하는지 확인합니다. 이 오류가 Step Functions에서 포착할 대상이 됩니다.

```JSON
{
  "Error": "CustomError",
  "Cause": "{\"errorMessage\":\"This is a custom error!\",...}"
}
```

---

## 2. 🏗️ Retry 및 Catch 로직이 포함된 State Machine 정의

이제 Lambda 함수의 오류를 처리할 상태 머신을 정의합니다.

1. AWS Step Functions 콘솔에서 **'상태 머신 생성(Create state machine)'**을 클릭하고, **'빈 상태 머신(Start with a blank workflow)'**을 선택합니다.
    
2. '코드(Code)' 탭에 아래의 JSON 코드를 붙여넣습니다. `Task` 상태의 `Resource` 필드에 위에서 생성한 Lambda 함수의 ARN을 붙여넣는 것을 잊지 마세요.
    

### 워크플로우 분석

- **`LambdaInvoke`**: 이 상태는 우리가 만든 Lambda 함수를 호출합니다.
    
- **`Retry`**: 이 블록은 오류 유형에 따라 재시도 로직을 정의합니다.
    
    - `CustomError`: 1초 간격으로 최대 2번 재시도합니다.
        
    - `TaskFailed`: 30초 간격으로 최대 3번 재시도합니다.
        
    - `States.ALL`: 그 외 모든 오류에 대해 5초 간격으로 최대 5번 재시도합니다.
        
- **`Catch`**: `Retry` 시도가 모두 실패하면 이 블록이 실행됩니다.
    
    - `CustomError` 발생 시: `CustomErrorFallback` 상태로 이동합니다.
        
    - `TaskFailed` 발생 시: `ReservedTypeFallback` 상태로 이동합니다.
        
    - `States.ALL` 발생 시: `CatchAllFallback` 상태로 이동합니다.
        
- **Fallback States**: 각 `Fallback` 상태는 오류 유형에 따라 다른 성공(Pass) 상태를 정의합니다.
    



```JSON
{
  "Comment": "A state machine that demonstrates retry and catch logic.",
  "StartAt": "LambdaInvoke",
  "States": {
    "LambdaInvoke": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Parameters": {
        "FunctionName": "arn:aws:lambda:us-east-1:123456789012:function:MyLambdaFunctionThatFails"
      },
      "Retry": [
        { "ErrorEquals": ["CustomError"], "IntervalSeconds": 1, "BackoffRate": 2, "MaxAttempts": 2 },
        { "ErrorEquals": ["TaskFailed"], "IntervalSeconds": 30, "BackoffRate": 2, "MaxAttempts": 3 },
        { "ErrorEquals": ["States.ALL"], "IntervalSeconds": 5, "BackoffRate": 2, "MaxAttempts": 5 }
      ],
      "Catch": [
        { "ErrorEquals": ["CustomError"], "Next": "CustomErrorFallback" },
        { "ErrorEquals": ["TaskFailed"], "Next": "ReservedTypeFallback" },
        { "ErrorEquals": ["States.ALL"], "Next": "CatchAllFallback" }
      ],
      "End": true
    },
    "CustomErrorFallback": { "Type": "Pass", "Result": "Handled Custom Error", "End": true },
    "ReservedTypeFallback": { "Type": "Pass", "Result": "Handled Reserved Error", "End": true },
    "CatchAllFallback": { "Type": "Pass", "Result": "Handled All Other Errors", "End": true }
  }
}
```

---

## 3. 🚀 실행 및 결과 확인

### 시나리오 1: `CustomError` 발생

- 기본 Lambda 함수는 **`CustomError`**를 발생시킵니다.
    
- 워크플로우를 실행하면, **`LambdaInvoke`** 상태가 두 번 실패한 후 **`CustomErrorFallback`** 상태로 이동하여 성공적으로 종료되는 것을 확인할 수 있습니다.
    
- **이벤트 기록(Event history)**에서 1초, 2초 간격으로 재시도가 발생하고 최종적으로 `CustomErrorFallback`으로 전환된 기록을 볼 수 있습니다.
    

### 시나리오 2: 다른 오류 유형 발생

- Lambda 함수 코드를 수정하여 **`CustomError`**가 아닌 다른 오류(예: `AnotherError`)를 발생시킵니다.
    
- 워크플로우를 다시 실행합니다. 이번에는 `CustomError` 규칙과 일치하지 않으므로, 다음 재시도 규칙(`TaskFailed`)을 따릅니다.
    
- **이벤트 기록**을 보면, 첫 번째 실패 후 **30초**를 기다렸다가 재시도하고, 다시 실패하면 **60초**를 기다렸다가 재시도하는 것을 확인할 수 있습니다.
    
- 결국 모든 재시도 횟수를 소진한 후, **`ReservedTypeFallback`** 상태로 이동하여 종료됩니다.
    

이 실습을 통해 Step Functions가 오류 유형에 따라 **재시도 횟수, 간격, 그리고 최종적인 복구 경로**를 유연하게 제어하는 강력한 기능을 제공함을 이해할 수 있습니다. 이를 활용하면 애플리케이션의 복잡성을 크게 줄이고 안정성을 높일 수 있습니다.