
이번 가이드에서는 Amazon API Gateway의 **스테이지 변수(Stage Variables)**를 활용하여 여러 Lambda 함수 버전 및 별칭(Alias)을 동적으로 연결하는 방법을 상세히 알아보겠습니다. 이를 통해 API를 재배포하지 않고도 환경별로 다른 백엔드 서비스를 호출하는 유연한 아키텍처를 구축할 수 있습니다.

---

## 💻 1단계: 여러 Lambda 함수 버전 및 별칭 생성하기

먼저, API Gateway와 연동할 Lambda 함수를 만들고, 여러 버전에 대한 별칭을 생성합니다.

1. **함수 생성**: `api-gateway-stage-variables-get`라는 이름으로 Lambda 함수를 생성합니다.
    
2. **버전 1 코드**: 다음 코드를 붙여넣고 **배포**한 뒤, **새 버전 게시(Publish new version)**를 클릭하여 **버전 1**을 생성합니다.

```Python
import json

def lambda_handler(event, context):
    return {
        'statusCode': 200,
        'headers': {'Content-Type': 'application/json'},
        'body': json.dumps('Hello from Lambda v1')
    }
```

3. **버전 2 코드**: 함수 코드를 `'Hello from Lambda v2'`로 수정하고 **배포**한 뒤, **새 버전 게시**를 클릭하여 **버전 2**를 생성합니다.
    
4. **최신 버전 코드**: 코드를 `'Hello from Lambda in DEV'`로 다시 수정하고 **배포**만 하고 버전을 게시하지 않습니다. 이 코드는 `$LATEST` 버전으로 남겨둡니다.
    

---

### ✨ Lambda 별칭 생성하기

이제 각 Lambda 버전들을 가리키는 **별칭(Alias)**을 생성합니다. 별칭을 사용하면 특정 Lambda 버전에 대한 포인터 역할을 하여, API Gateway는 별칭만 호출하고 별칭이 실제 버전을 가리키도록 설정할 수 있습니다.

|별칭 이름|설명|
|---|---|
|**`PROD`**|가장 안정적인 **버전 1**을 가리킵니다.|
|**`TEST`**|테스트 중인 **버전 2**를 가리킵니다.|
|**`DEV`**|개발 중인 **`$LATEST`** 버전을 가리킵니다.|

---

## 🔗 2단계: API Gateway와 Lambda 별칭 동적 연결하기

이제 API Gateway에서 스테이지 변수를 사용하여 위에서 생성한 Lambda 별칭을 동적으로 호출하도록 설정합니다.

1. **새 리소스 생성**: API Gateway 콘솔에서 `/` 리소스 아래에 `stage-variables`라는 이름의 리소스를 생성합니다.
    
2. **GET 메서드 생성**: `/stage-variables` 리소스에 **GET** 메서드를 추가합니다.
    
3. **Lambda 함수 ARN 입력**:
    
    - **통합 유형**: Lambda 함수
        
    - **프록시 통합 사용**: 체크
        
    - **Lambda 함수**: Lambda 함수의 ARN을 입력하되, 끝에 `:dev` 대신 스테이지 변수를 사용합니다.
        
    - **Lambda ARN 형식**: `arn:aws:lambda:REGION:ACCOUNT_ID:function:FUNCTION_NAME:${stageVariables.lambdaAlias}`
        

### 📜 IAM 권한 부여하기

이 설정은 API Gateway가 `dev`, `test`, `prod`와 같이 동적으로 변하는 Lambda 별칭을 호출하도록 합니다. 따라서 각 별칭에 대해 API Gateway 호출 권한을 명시적으로 부여해야 합니다. 다음 명령어를 AWS CloudShell에서 실행합니다.

```Bash
aws lambda add-permission \
--function-name arn:aws:lambda:REGION:ACCOUNT_ID:function:FUNCTION_NAME:PROD \
--statement-id "AllowAPIGatewayInvokePROD" \
--action lambda:InvokeFunction \
--principal apigateway.amazonaws.com \
--source-arn "arn:aws:execute-api:REGION:ACCOUNT_ID:API_ID/*/GET/stage-variables"

aws lambda add-permission \
--function-name arn:aws:lambda:REGION:ACCOUNT_ID:function:FUNCTION_NAME:TEST \
--statement-id "AllowAPIGatewayInvokeTEST" \
--action lambda:InvokeFunction \
--principal apigateway.amazonaws.com \
--source-arn "arn:aws:execute-api:REGION:ACCOUNT_ID:API_ID/*/GET/stage-variables"

aws lambda add-permission \
--function-name arn:aws:lambda:REGION:ACCOUNT_ID:function:FUNCTION_NAME:DEV \
--statement-id "AllowAPIGatewayInvokeDEV" \
--action lambda:InvokeFunction \
--principal apigateway.amazonaws.com \
--source-arn "arn:aws:execute-api:REGION:ACCOUNT_ID:API_ID/*/GET/stage-variables"
```

---

## ✅ 3단계: 스테이지 변수 설정 및 API 배포하기

이제 각 스테이지에 맞는 `lambdaAlias` 스테이지 변수를 설정하고 API를 배포합니다.

1. **API 배포**: **API 배포(Deploy API)**를 클릭하고, `dev`라는 새로운 스테이지를 생성합니다.
    
2. **스테이지 변수 설정**: `dev` 스테이지로 이동하여 **스테이지 변수(Stage Variables)** 탭을 클릭합니다.
    
    - **이름**: `lambdaAlias`
        
    - **값**: `DEV`
        
3. **다른 스테이지 배포**: 동일한 방식으로 `TEST`와 `PROD` 스테이지를 추가로 생성하고 각각의 `lambdaAlias` 변수 값을 `TEST`와 `PROD`로 설정합니다.

|스테이지|스테이지 변수 이름|스테이지 변수 값|
|---|---|---|
|`dev`|`lambdaAlias`|`DEV`|
|`test`|`lambdaAlias`|`TEST`|
|`prod`|`lambdaAlias`|`PROD`|

---

## 🌐 4단계: 최종 결과 확인하기

마지막으로, 배포된 API의 URL을 사용하여 각 스테이지를 호출하고 스테이지 변수가 정상적으로 작동하는지 확인합니다.

- **PROD 환경 테스트**:
    
    - URL: `https://your-api-id.execute-api.region.amazonaws.com/prod/stage-variables`
        
    - 결과: `"Hello from Lambda v1"`
        
- **TEST 환경 테스트**:
    
    - URL: `https://your-api-id.execute-api.region.amazonaws.com/test/stage-variables`
        
    - 결과: `"Hello from Lambda v2"`
        
- **DEV 환경 테스트**:
    
    - URL: `https://your-api-id.execute-api.region.amazonaws.com/dev/stage-variables`
        
    - 결과: `"Hello from Lambda in DEV"`


이처럼 스테이지 변수를 사용하면 단 하나의 API Gateway 메서드 설정만으로도 URL에 따라 다른 Lambda 별칭을 호출할 수 있습니다. 이는 **환경별로 다른 백엔드 로직을 분리**하고 **배포를 유연하게 관리**하는 데 있어 매우 강력한 패턴입니다.