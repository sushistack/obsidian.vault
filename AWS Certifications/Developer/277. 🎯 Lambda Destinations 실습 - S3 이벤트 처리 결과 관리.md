
이번 실습에서는 **Lambda Destinations** 기능을 직접 사용하여 S3 이벤트로 트리거되는 람다 함수의 실행 결과를 관리하는 방법을 살펴보겠습니다. 람다 함수의 성공(Success) 및 실패(Failure) 결과에 따라 메시지를 다른 SQS(Simple Queue Service) 큐로 보내는 과정을 단계별로 진행합니다.

---

## 1. SQS 대기열(Queue) 생성

먼저, 람다 함수의 성공 및 실패 결과를 받을 두 개의 SQS 큐를 생성해야 합니다.

- `S3-success`: 람다 함수가 성공적으로 실행되었을 때 메시지를 받을 큐
    
- `S3-failure`: 람다 함수 실행 중 예외가 발생하여 실패했을 때 메시지를 받을 큐

SQS 콘솔에서 각 큐의 이름을 지정하고 기본 설정으로 생성합니다.

---

## 2. 람다 함수에 Destinations 설정

두 개의 SQS 큐가 준비되었다면, 람다 함수 (`lambda S3 function`)의 **`Configuration`** 탭으로 이동하여 Destinations를 추가합니다.

1. **`Destinations`** 메뉴에서 `Add destination`을 클릭합니다.
    
2. **`Source`** 타입은 **`Asynchronous invocation`**으로 설정합니다.
    
3. **성공 조건 추가:**
    
    - **`Condition`**을 **`On success`**로 선택합니다.
        
    - **`Destination type`**은 **`SQS queue`**를 선택합니다.
        
    - **`Destination`** 드롭다운에서 `S3-success` 큐를 선택합니다.
        
4. **실패 조건 추가:**
    
    - **`Condition`**을 **`On failure`**로 선택합니다.
        
    - **`Destination type`**은 **`SQS queue`**를 선택합니다.
        
    - **`Destination`** 드롭다운에서 `S3-failure` 큐를 선택합니다.
        

✅ 권한 자동 추가:

Destinations를 설정하면 람다 함수가 SQS 큐에 메시지를 보낼 수 있도록 IAM 실행 역할(Execution Role)에 필요한 sqs:SendMessage 권한이 자동으로 추가됩니다. IAM 콘솔에서 람다 함수의 역할을 확인하면, Destinations에 대한 LambdaSQSQueueDestinationExecutionRole 정책이 생성된 것을 볼 수 있습니다.

---

## 3. 성공 및 실패 이벤트 테스트

이제 Destinations 설정이 올바르게 작동하는지 확인하기 위해 두 가지 시나리오를 테스트합니다.

### 🟢 성공 시나리오

1. 람다 함수 코드를 **성공적으로 실행되도록** 유지합니다. (예: 단순히 객체를 반환하는 코드)
    
2. S3 버킷에 파일을 업로드하여 람다 함수를 비동기적으로 트리거합니다.
    
3. SQS 콘솔로 이동하여 `S3-success` 큐를 확인합니다. `Available` 메시지 수가 1로 표시됩니다.
    
4. 큐의 **`Send and receive messages`** 탭에서 메시지를 폴링(poll)하면, 메시지 본문에서 **성공적으로 처리된 S3 이벤트와 람다 함수의 응답 페이로드**를 확인할 수 있습니다.
    

**메시지 본문 구성:**

- `requestContext`: 호출에 대한 정보
    
- `responsePayload`: 람다 함수의 반환 값 (예: `{"statusCode": 200, "body": "..."}`)
    
- `Records`: 람다 함수를 호출한 원본 이벤트 레코드 (예: S3 `ObjectCreated:Put` 이벤트)
    

### 🔴 실패 시나리오

1. 람다 함수 코드를 수정하여 **예외(`Exception`)를 발생**시킵니다.
    
    
```Python
def lambda_handler(event, context):
	raise Exception("Boom!")
```
    
2. 변경된 코드를 배포(Deploy)한 후, S3 버킷에 다시 파일을 업로드합니다.
    
3. SQS 콘솔로 이동하여 `S3-failure` 큐를 확인합니다.
    
4. 처음에는 메시지가 보이지 않을 수 있습니다. 이는 람다의 비동기 호출이 기본적으로 **2번의 재시도(retry)**를 수행하기 때문입니다. 재시도가 모두 실패한 후에야 `S3-failure` 큐로 메시지가 전송됩니다.
    
5. 잠시 후 `S3-failure` 큐에 `Available` 메시지가 1로 표시됩니다.
    
6. 메시지를 폴링하면, 메시지 본문에서 **실패의 원인과 스택 트레이스**를 확인할 수 있습니다.

**메시지 본문 구성:**

- `requestContext`: 재시도 횟수 (`approximateInvokeCount`), 실패 이유 (`condition: Retries exhausted`)
    
- `responsePayload`: 예외 메시지 (`errorMessage`), 예외 타입 (`errorType`), 스택 트레이스 (`stackTrace`)
    
- `Records`: 람다 함수를 실패하게 만든 원본 이벤트 레코드

이처럼 Destinations를 활용하면 람다 함수 실행 결과를 체계적으로 관리하고, 실패 원인을 쉽게 파악하여 안정적인 서버리스 애플리케이션을 구축할 수 있습니다.