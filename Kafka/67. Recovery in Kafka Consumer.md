
## Approches

첫 번째 접근 방식은 실패한 메시지를 다시 처리하는 것입니다.

그렇다면 이러한 작업을 수행해야 하는 시나리오는 무엇일까요? 예를 들어, 소비자가 소비자 로직의 일부로 다른 서비스를 호출한다고 가정해 보겠습니다.

해당 서비스가 일시적으로 다운되었거나 유지 보수 중인 경우, 메시지를 다시 재생하여 성공하도록 해야 할 수 있습니다.

또 다른 접근 방식은 실패한 메시지를 폐기하고 다음으로 넘어가는 것입니다.

예시로는 파싱 오류나 유효하지 않은 이벤트가 포함됩니다. 예를 들어, 존재하지 않는 레코드에 대한 업데이트 이벤트를 발행하는 것은 유효하지 않은 이벤트이며, 이러한 종류의 메시지는 복구 로직의 일부로 동일한 메시지를 계속해서 재시도할 의미가 없습니다. 왜냐하면 이러한 메시지는 절대 복구될 수 없기 때문입니다.

---

첫 번째 옵션은 메시지를 재시도 토픽에 게시하고, 소비자가 재시도 토픽에서 메시지를 읽은 다음 소비자 로직을 다시 호출하도록 하는 것입니다.

이것이 한 가지 옵션입니다.

두 번째 옵션은 실패한 메시지를 데이터베이스에 저장하고 스케줄러를 사용하여 동일한 메시지를 재시도하는 것입니다.

이것이 두 번째 옵션입니다.

이 두 가지 옵션을 적용하면, 라이브러리 이벤트 소비자에 대한 아키텍처가 어떻게 될지 보여드리고자 합니다.

## Error in Kafka Consumer

![](Pasted%20image%2020241120144927.png)


## Retry in Kafka Consumer

![](Pasted%20image%2020241120144943.png)



![](Pasted%20image%2020241120144954.png)

## Retry and Recovery

![](Pasted%20image%2020241120145011.png)

### Recvery - type 1

![](Pasted%20image%2020241120145021.png)



### Recvery - type 2

![](Pasted%20image%2020241120145051.png)

복구는 이벤트 순서를 변경할 수 있습니다

![](Pasted%20image%2020241120145157.png)

