
![](Pasted%20image%2020241115103246.png)

**리더 브로커가 다운되는 상황**

1. **브로커 1**이 **파티션 0의 리더**인 상황에서 **브로커 1**이 다운된다면, 이때 **파티션 0**의 데이터는 **브로커 1**의 파일 시스템에 저장되어 있기 때문에, **클라이언트는 이 데이터를 접근할 수 없게 되어 데이터 손실이 발생**합니다.

• 이는 Kafka에서 중요한 문제로, **데이터 손실**을 피해야 합니다.

**복제(replication)로 해결**

![](Pasted%20image%2020241115103424.png)

```sh
./kafka-topics.sh - \

--replication-factor 3 \

```

Kafka는 **복제**를 통해 이 문제를 해결합니다. **복제**는 데이터가 여러 브로커에 **복제본을 생성**하여 **데이터 손실**을 방지하는 방식입니다.

• **복제 계수(replication factor)**는 각 메시지의 **복제본 수**를 나타냅니다. 예를 들어, **복제 계수가 3**이라면, **메시지가 3개 브로커에 저장**됩니다.
• 예시로, **브로커 1**이 **파티션 0의 리더**라고 가정했을 때, 프로듀서가 메시지를 보내면 **브로커 1**에 메시지가 저장됩니다.
• 이후, 이 메시지는 **브로커 2**와 **브로커 3**에도 복제됩니다.
• 이 과정에서 **브로커 2**와 **브로커 3**은 **팔로워 복제본(follower replicas)**이 됩니다.
**리더 복제본(leader replica)**은 **브로커 1**이고, **팔로워 복제본(follower replicas)**은 **브로커 2**와 **브로커 3**입니다.


**브로커 실패 시 복구**

이제 브로커 1이 **다운**되었다고 가정해봅시다. 하지만 **브로커 2**와 **브로커 3**에 동일한 데이터가 있기 때문에, **파티션의 데이터는 여전히 안전**합니다.

• **Zookeeper**는 브로커 1의 실패를 감지하고, **새로운 리더**를 선출합니다.
• 이 경우 **브로커 2**가 **파티션 0**의 **새 리더**로 선출됩니다.
• 그 후, 클라이언트는 **파티션 0**의 데이터를 **브로커 2**로 전송하며, 데이터의 생산과 소비가 이루어집니다.

이렇게 Kafka는 **데이터 손실** 없이 **리더 브로커의 실패를 처리**할 수 있습니다.


**동기화된 복제본 (In-Sync Replicas, ISR)**

다음으로 **“동기화된 복제본(In-Sync Replicas, ISR)”**에 대해 설명합니다.

• **ISR**은 **리더 브로커와 팔로워 브로커** 간의 **동기화된 복제본의 수**를 나타냅니다. 이는 **리더 브로커**와 **팔로워 브로커**가 **동기화되어 있을 때만** 데이터를 안전하게 유지할 수 있음을 의미합니다.
• **리더 브로커**와 **팔로워 브로커** 모두 **동기화 상태**여야 하며, **동기화된 복제본**이 하나 이상 있어야 데이터의 안정성을 보장할 수 있습니다.
• **최적의 복제 상태**는 **ISR(동기화된 복제본 수)**가 **복제 계수(replication factor)**와 같을 때입니다. 즉, **모든 복제본이 동기화되어야** 합니다.

**min.insync.replicas**는 Kafka의 **복제 설정** 중 하나로, 이 값은 **동기화된 복제본의 최소 개수**를 설정할 수 있습니다. 이 설정은 **복제본이 최소한 이 수 이상이 되어야만 메시지를 쓸 수 있게** 합니다. 이 값은 **브로커 수준** 또는 **토픽 수준**에서 설정할 수 있습니다.

### 요약

• **리더 브로커**는 **각 파티션의 데이터를 저장**하고, **팔로워 브로커**는 **리더 브로커의 데이터를 복제**합니다.
• **복제 계수(replication factor)**를 사용하여 데이터를 여러 브로커에 복제하여 **데이터 손실을 방지**하고 **고가용성**을 보장합니다.
• **동기화된 복제본(In-Sync Replicas, ISR)**을 사용하여, **리더와 팔로워 브로커 간의 동기화 상태**를 보장하고 **데이터 일관성**을 유지합니다.
• **min.insync.replicas**를 통해 동기화된 복제본의 최소 개수를 설정하여, **안전한 데이터 처리**를 할 수 있습니다.


