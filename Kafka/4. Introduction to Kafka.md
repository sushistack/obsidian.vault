![[www.udemy.com_course_apache-kafka-for-developers-using-springboot_learn_lecture_17280366.png]]

과거와 현재의 아키텍쳐 차이

![[www.udemy.com_course_apache-kafka-for-developers-using-springboot_learn_lecture_17280366 (1).png]]

요즘은 Event Streaming Paltform 을 이용하여 구성됨


![[www.udemy.com_course_apache-kafka-for-developers-using-springboot_learn_lecture_17280366 (2).png]]

- 프로듀서와 컨슈머는 레코드들의 Stream에 구독하는 주체
	- 프로듀서와 컨슈머는 독립적이다 (디커플링 되어 있다.)
- 이벤트들의 Stream 을 저장
	- 필요한 경우, 이를 메시지 형태로 컨슈머 등에게 전달 수 있다.
- 이벤트 스트리밍 플랫폼은 이벤트가 발생하는 대로 분석 혹은 처리할 수 있다.


![[www.udemy.com_course_apache-kafka-for-developers-using-springboot_learn_lecture_17280366 (3).png]]

### 기존 메시징 시스템

- 일시적인 메시지 지속성을 갖는다.
	- 컨슈머가 메시지를 읽으면 메시지 브로커에서 제거된다.
- 컨슈머가 소비한 메시지를 추적하고 삭제는 행위가 메시지 브로커 자체에 있다.
- 메시지 브로커로부터 메시지를 소비하기 위한 특정 컨슈머를 선택한다.
- 일반적으로 분산 시스템의 원칙을 따르지 않는 경우가 많다.


### 카프카 (Streaming Platform)

- 카프카의 경우 카프카가 설치된 파일 시스템에 이벤트를 저장하고 이벤트는 일정 시간 동안 보관
- 카프카로 프로듀싱된 메시지는 immutable 이다.
- 카프카의 경우, 컨슈머가 소비한 메시지를 추적해야 한다.
- 카프카의 경우, 접근 가능한 모든 컨슈머들은 메시지를 읽을 수 있다.
- 카프카의 경우 분산 시스템의 원칙을 기반으로 구축되어 있다. 

#### 비교 메시지 컨슘에 대한 관리 주체 비교

전통적인 메시징 시스템에서는 **브로커**가 각 **컨슈머**(consumer)가 소비한 메시지를 추적하고, 메시지가 읽히면 브로커가 해당 메시지를 삭제하는 방식으로 동작합니다. 즉, 메시지의 소비와 관리가 브로커에 의해 중앙 집중적으로 관리됩니다. 예를 들어, RabbitMQ와 같은 메시징 시스템에서는 브로커가 소비된 메시지를 기억하고, 컨슈머가 읽은 뒤에 메시지를 삭제하거나 표시합니다.

반면에, **Apache Kafka**에서는 메시지의 소비 상태를 관리하는 책임이 **컨슈머**에게 있습니다. 컨슈머가 메시지를 읽고 나면, 이 메시지를 어디까지 읽었는지 기록하는 방식으로 진행합니다. Kafka에서는 컨슈머가 읽은 메시지를 삭제하지 않고, **오프셋(offset)**을 사용하여 어디까지 읽었는지를 트래킹합니다. Kafka의 브로커는 단순히 메시지를 저장하고, 메시지가 주기적으로 삭제되는 방식(retention policy)으로 관리할 뿐, 개별 컨슈머가 메시지를 읽었는지 여부는 관여하지 않습니다.

Kafka의 이 구조는 다음과 같은 특징이 있습니다:

1. **내구성**: 메시지가 소비된 후에도 브로커에 남아 있으므로, 다른 컨슈머가 동일한 메시지를 읽을 수 있습니다.
2. **유연성**: 컨슈머가 원하는 시점에 특정 오프셋부터 다시 메시지를 읽을 수 있어 재처리가 용이합니다.
3. **확장성**: 브로커가 각 컨슈머의 상태를 추적할 필요가 없어, 많은 수의 컨슈머를 처리하는 데 유리합니다.

결론적으로, 전통적인 메시징 시스템은 브로커가 메시지 상태를 관리하는 반면, Kafka에서는 컨슈머가 메시지 상태를 스스로 관리합니다.


#### pull 방식과 push 방식에 따른 차이

전통적인 메시징 시스템은 보통 **push 방식**을 사용합니다. 이 방식에서는 브로커가 메시지를 특정 컨슈머에게 **직접 푸시(push)**하는 형태로 동작합니다. 브로커가 메시지를 관리하고, 어떤 컨슈머가 어느 메시지를 받을지 결정하며, 메시지가 소비되면 삭제합니다. 따라서, 특정 컨슈머에게 메시지를 할당할 수 있고, 필요한 경우 개별 메시지를 특정 컨슈머에게 보낼 수 있는 구조가 됩니다.

반면에, **Kafka**는 **pull 방식**을 채택하고 있습니다. Kafka에서는 브로커가 메시지를 자동으로 푸시하지 않고, **컨슈머가 필요할 때 브로커로부터 메시지를 가져오는(pull)** 방식으로 메시지를 소비합니다. 이로 인해 컨슈머가 소비할 메시지를 직접 요청하는 구조가 되어, 특정 컨슈머만을 대상으로 메시지를 보내는 것이 아닌, 컨슈머가 필요에 따라 자유롭게 메시지를 가져갈 수 있는 시스템이 됩니다.

이 방식은 다음과 같은 차이를 만들어냅니다:

1. **컨슈머 주도 소비**: pull 방식에서는 컨슈머가 주도적으로 메시지를 가져가므로, 각 컨슈머가 메시지를 어디까지 소비했는지를 스스로 관리해야 합니다. Kafka에서는 이를 오프셋(offset)을 통해 구현하고 있습니다.

2. **유연한 소비 속도**: push 방식에서는 브로커가 메시지를 푸시하기 때문에, 컨슈머가 이를 빠르게 처리하지 못하면 오버로드가 발생할 수 있습니다. 반면에, pull 방식에서는 컨슈머가 메시지 처리 속도를 조절할 수 있어, 자신의 처리 능력에 맞춰 메시지를 가져올 수 있습니다.

3. **확장성 및 중복 소비 방지**: Kafka의 pull 방식과 컨슈머 그룹 구조는 확장성에 유리하며, 중복 소비를 방지하기 위해 한 컨슈머 그룹 내의 각 파티션(partition)을 하나의 컨슈머만 읽을 수 있도록 설정할 수 있습니다.

따라서, Kafka의 pull 방식은 컨슈머가 주도적으로 메시지를 소비하게 되어 특정 컨슈머만 대상으로 메시지를 보내기 어렵고, 모든 컨슈머가 동일한 메시지에 접근할 수 있는 구조를 만듭니다.


![[www.udemy.com_course_apache-kafka-for-developers-using-springboot_learn_lecture_17280366 (4).png]]

다양 유즈케이스에 사용되고 있다.