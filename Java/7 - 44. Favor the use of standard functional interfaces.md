**표준 함수형 인터페이스**를 사용하여 코드의 **일관성**과 **재사용성**을 높이는 것이 좋다

자바 8부터 제공되는 **표준 함수형 인터페이스**는 **`java.util.function` 패키지**에 정의되어 있으며, 이들 인터페이스는 **함수형 프로그래밍**을 간결하게 표현할 수 있는 도구입니다. 가능한 경우, 새롭게 정의된 함수형 인터페이스를 사용하기보다는 **자바에서 제공하는 표준 함수형 인터페이스**를 사용하는 것이 바람직합니다.

### 1. 주제: **표준 함수형 인터페이스를 사용하는 이유**

자바에서 **함수형 인터페이스**는 하나의 추상 메서드만을 가진 인터페이스를 말합니다. 함수형 인터페이스를 사용하면 **람다 표현식**을 사용하여 매우 간결한 코드를 작성할 수 있습니다. 자바는 자주 사용되는 패턴을 다루기 위해 **미리 정의된 함수형 인터페이스**를 제공하며, 이러한 **표준 인터페이스**를 사용하면 코드의 **일관성**이 유지되고, **재사용성**이 향상됩니다.

### 2. 표준 함수형 인터페이스의 개요

**`java.util.function` 패키지**는 자바에서 가장 흔히 사용되는 함수형 인터페이스들의 모음을 제공합니다. 이들은 다양한 용도로 사용할 수 있으며, 일반적으로 **함수형 프로그래밍**을 사용할 때 유용합니다. 이러한 인터페이스는 크게 **4가지 주요 카테고리**로 나눌 수 있습니다.

#### (1) **`Predicate<T>`**

- **설명**: **인수 T**를 받아 **논리값(true/false)**을 반환하는 함수형 인터페이스.
- **추상 메서드**: `boolean test(T t)`
- **사용 예시**: 필터링 작업에서 자주 사용됩니다.

```java
Predicate<String> isLongString = s -> s.length() > 5;
System.out.println(isLongString.test("HelloWorld"));  // true
```

#### (2) **`Function<T, R>`**

- **설명**: **인수 T**를 받아 **결과 R**을 반환하는 함수형 인터페이스.
- **추상 메서드**: `R apply(T t)`
- **사용 예시**: 데이터 변환 작업에 자주 사용됩니다.

```java
Function<Integer, String> intToString = n -> "Number: " + n;
System.out.println(intToString.apply(5));  // "Number: 5"
```

#### (3) **`Supplier<T>`**

- **설명**: **인수 없이** **결과 T**를 반환하는 함수형 인터페이스.
- **추상 메서드**: `T get()`
- **사용 예시**: 객체 생성이나 기본값 제공에 자주 사용됩니다.

```java
Supplier<Double> randomSupplier = () -> Math.random();
System.out.println(randomSupplier.get());  // 랜덤 값 출력
```

#### (4) **`Consumer<T>`**

- **설명**: **인수 T**를 받아 **아무것도 반환하지 않는(부수 효과만 있는)** 함수형 인터페이스.
- **추상 메서드**: `void accept(T t)`
- **사용 예시**: 데이터를 소비하거나 출력하는 작업에 자주 사용됩니다.


```java
Consumer<String> printer = s -> System.out.println(s);
printer.accept("Hello, World!");  // "Hello, World!" 출력
```

### 3. 표준 함수형 인터페이스의 장점

#### 1) **일관성 유지**

자바에서 제공하는 **표준 함수형 인터페이스**를 사용하면 코드의 **일관성**을 유지할 수 있습니다. 예를 들어, 개발자가 자주 사용하는 패턴을 위해 **새로운 함수형 인터페이스를 정의**하지 않아도 되므로, 코드가 더 **표준화**되고 이해하기 쉬워집니다.

```java
// 새로운 함수형 인터페이스를 정의하지 않고 표준 인터페이스 사용
Predicate<Integer> isEven = n -> n % 2 == 0;
```

#### 2) **재사용성**

**표준 함수형 인터페이스**는 다양한 상황에서 재사용할 수 있습니다. `Predicate`, `Function`, `Consumer`, `Supplier`는 모두 매우 **일반적인 용도**로 설계되었기 때문에, 이를 활용하면 **재사용 가능성이 높은 코드**를 작성할 수 있습니다.

```java
Function<String, Integer> stringLength = String::length;
System.out.println(stringLength.apply("Hello"));  // 5
```

이처럼 자주 사용되는 기능을 **재사용**하는 것은 유지보수성을 크게 향상시킵니다.

#### 3) **람다 표현식과의 결합**

**람다 표현식**과 함께 사용할 수 있기 때문에, 코드의 **간결성**이 극대화됩니다. **표준 함수형 인터페이스**는 **메서드 참조**와도 쉽게 결합할 수 있어, 함수형 프로그래밍 스타일의 코드를 매우 간단하게 작성할 수 있습니다.

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
names.forEach(System.out::println);
```

위 코드에서 `Consumer` 인터페이스는 **메서드 참조**와 결합되어 코드가 매우 간결해집니다.

#### 4) **기본 메서드 제공**

자바의 **표준 함수형 인터페이스**는 기본적으로 **`and`, `or`, `negate`**와 같은 **기본 메서드**를 제공합니다. 이를 통해 여러 함수를 쉽게 조합할 수 있습니다.

```java
Predicate<String> startsWithA = s -> s.startsWith("A");
Predicate<String> lengthIs3 = s -> s.length() == 3;
Predicate<String> combined = startsWithA.and(lengthIs3);

System.out.println(combined.test("Ant"));  // true
```

위 예시에서 **`and()` 메서드**를 사용하여 두 개의 `Predicate`를 결합했습니다. 이러한 방식으로 함수를 쉽게 조합할 수 있어 **유연성**이 높습니다.

### 4. 표준 함수형 인터페이스 사용을 피할 때

표준 함수형 인터페이스가 **모든 상황에 적합한 것은 아닙니다**. 복잡한 비즈니스 로직을 처리하거나 **도메인에 특화된 작업**이 필요한 경우에는 **새로운 함수형 인터페이스**를 정의하는 것이 더 적합할 수 있습니다.

#### (1) **도메인 특화 로직**

도메인 특화된 비즈니스 로직이나 복잡한 동작을 표현할 때, **표준 인터페이스가 충분하지 않은 경우**가 있습니다. 예를 들어, 특정 도메인의 작업에 특화된 함수형 인터페이스가 필요할 수 있습니다.

```java
@FunctionalInterface
public interface StringProcessor {
    String process(String s);
}

StringProcessor processor = s -> s.trim().toUpperCase();
System.out.println(processor.process("   hello world   "));  // "HELLO WORLD"
```

위 예시에서는 **문자열 처리**에 특화된 함수형 인터페이스를 정의했습니다. 이 경우 **표준 함수형 인터페이스**보다 **도메인 특화 인터페이스**를 정의하는 것이 더 적합할 수 있습니다.

#### (2) **복잡한 시그니처**

표준 함수형 인터페이스는 단순한 시그니처를 가지는 함수형 인터페이스에 적합합니다. 하지만 **매개변수의 수가 많거나 복잡한 시그니처**가 필요한 경우에는 표준 인터페이스가 적합하지 않을 수 있습니다.

```java
@FunctionalInterface
public interface TriFunction<T, U, V, R> {
    R apply(T t, U u, V v);
}

TriFunction<Integer, Integer, Integer, Integer> addThreeNumbers = (a, b, c) -> a + b + c;
System.out.println(addThreeNumbers.apply(1, 2, 3));  // 6
```

위 예시에서는 **세 개의 인수**를 처리하는 함수형 인터페이스를 정의했습니다. **표준 인터페이스**로는 이를 처리할 수 없기 때문에 **커스텀 인터페이스**를 정의했습니다.

### 5. 주요 표준 함수형 인터페이스

- **`Predicate<T>`**: 입력값을 받아서 `boolean` 값을 반환하는 함수형 인터페이스.
- **`Function<T, R>`**: 입력값을 받아서 출력값을 반환하는 함수형 인터페이스.
- **`Supplier<T>`**: 입력값 없이 출력값을 반환하는 함수형 인터페이스.
- **`Consumer<T>`**: 입력값을 받아서 반환값 없이 소비하는 함수형 인터페이스.
- **`BiFunction<T, U, R>`**: 두 개의 입력값을 받아서 출력값을 반환하는 함수형 인터페이스.
- **`UnaryOperator<T>`**: 동일한 타입의 입력과 출력이 있는 함수형 인터페이스.
- **`BinaryOperator<T>`**: 동일한 타입의 두 개의 입력값을 받아서 동일한 타입의 출력값을 반환하는 함수형 인터페이스.

### 6. 요약

- **표준 함수형 인터페이스**를 사용하면 코드의 **일관성**, **재사용성**, **가독성**이 향상됩니다.
- **람다 표현식**과 결합하여 코드를 간결하게 작성할 수 있으며, 함수형 프로그래밍 스타일을 장려합니다.
- 자바의 **표준 함수형 인터페이스**는 데이터 변환, 필터링, 소비, 생성 등의 작업을 쉽게 처리할 수 있습니다.
- **도메인 특화된 작업**이나 **복잡한 함수 시그니처**가 필요한 경우에는 **새로운 함수형 인터페이스**를 정의할 수도 있습니다.

**결론적으로**, 가능한 경우에는 **자바의 표준 함수형 인터페이스**를 사용하는 것이 **효율적이고 가독성이 높은 코드**를 작성하는 데 도움이 됩니다. 이는 **재사용성**을 극대화하고, **일관된 코딩 스타일**을 유지하는 데 매우 유용합니다.