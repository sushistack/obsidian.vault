체를 참조할 때 구체적인 클래스 대신 **인터페이스**를 사용하라는 권장 사항입니다. 객체 참조를 인터페이스로 하면 코드의 유연성과 확장성이 높아지며, 유지보수와 테스트가 더 쉬워집니다. 구체적인 클래스를 사용하면 의존성이 고정되어, 변경 및 확장에 취약해질 수 있습니다.

**주요 개념:**

1. **인터페이스를 사용하여 참조하는 이점**

• **유연성**: 객체를 인터페이스로 참조하면, 객체의 구현체를 바꿔도 코드의 나머지 부분을 수정할 필요가 없습니다. 이는 특히 다양한 구현체가 있을 때 매우 유리합니다.

• **확장성**: 인터페이스를 사용하면 새로운 구현체를 쉽게 추가할 수 있습니다. 구체적인 클래스를 참조하면 해당 클래스만 사용해야 하지만, 인터페이스로 참조하면 다른 클래스를 교체하여 사용할 수 있습니다.

• **테스트 용이성**: 인터페이스를 사용하면 모킹(Mock)을 통한 단위 테스트가 더 쉬워집니다. 예를 들어, List 인터페이스로 참조한 객체는 테스트 시 ArrayList나 LinkedList와 같은 구현체를 자유롭게 바꿔가며 사용할 수 있습니다.

2. **구체적인 클래스 대신 인터페이스 사용 예시**

다음은 구체적인 클래스를 사용하는 예와 인터페이스를 사용하는 예를 비교한 것입니다.

**나쁜 예 (구체적인 클래스 사용)**:

```java
ArrayList<String> list = new ArrayList<>();
list.add("Alice");
```

**좋은 예 (인터페이스 사용)**:

```java
List<String> list = new ArrayList<>();
list.add("Alice");
```

**이유**: 첫 번째 예에서는 ArrayList 클래스를 직접 참조하고 있습니다. 만약 이 클래스를 다른 구현체(예: LinkedList)로 바꾸고 싶을 때는 코드를 수정해야 합니다. 반면, 두 번째 예에서는 List 인터페이스로 참조하고 있으므로, 다른 List 구현체로 쉽게 교체할 수 있습니다.

```java
List<String> list = new LinkedList<>();  // 쉽게 다른 구현체로 변경 가능
```

3. **구체적인 클래스 사용이 필요한 경우**

인터페이스로 참조하는 것이 일반적으로 좋은 습관이지만, 때로는 구체적인 클래스가 더 적합할 때도 있습니다. 특히, 구체적인 클래스에만 존재하는 특정 기능을 사용할 때는 해당 클래스의 메서드나 성능 최적화가 필요할 수 있습니다. 하지만 이러한 경우에도 최대한 인터페이스로 참조하는 습관을 유지하는 것이 좋습니다.

**예시**:

```java
ArrayList<String> list = new ArrayList<>(100);  // 초기 용량을 설정할 때는 ArrayList 사용이 필요
```

4. **인터페이스로 참조할 수 있는 경우**

자바에서 흔히 사용되는 몇 가지 대표적인 인터페이스와 그 구현체들입니다.

• **List** 인터페이스: ArrayList, LinkedList, CopyOnWriteArrayList
• **Set** 인터페이스: HashSet, TreeSet, LinkedHashSet
• **Map** 인터페이스: HashMap, TreeMap, LinkedHashMap, ConcurrentHashMap
• **Queue** 인터페이스: PriorityQueue, LinkedList, ArrayDeque

**인터페이스 참조 예시**:

```java
Map<String, Integer> map = new HashMap<>();  // HashMap 대신 다른 Map 구현체로 교체 가능
```

5. **추상 클래스와 인터페이스의 차이**

추상 클래스와 인터페이스는 모두 객체의 동작을 정의할 수 있지만, 둘 사이에는 차이가 있습니다. 추상 클래스는 구체적인 메서드를 포함할 수 있고 상속을 통해만 사용할 수 있는 반면, 인터페이스는 여러 개를 구현할 수 있어 더 유연합니다. 가능하면 **인터페이스**를 사용하는 것이 더 좋습니다.

6. **구체적인 클래스가 아닌 인터페이스로 참조해야 하는 이유**

• **코드 변경 최소화**: 인터페이스를 사용하면 구현체를 바꿔도 해당 코드를 사용하는 부분을 수정할 필요가 없습니다.

• **의존성 감소**: 구체적인 클래스에 의존하지 않기 때문에 객체 지향적인 설계 원칙(SOLID 원칙 중 하나인 DIP: 의존성 역전 원칙)을 따르게 됩니다.

• **코드 가독성 향상**: 인터페이스를 사용하면 코드가 더 추상적이고 이해하기 쉬워집니다. 구체적인 구현체보다는 객체가 무엇을 **할 수 있는지**에 집중할 수 있습니다.

**예시:**

**구체적인 클래스를 사용한 나쁜 예시:**

```java
public class ShoppingCart {
    private ArrayList<String> items = new ArrayList<>();  // 구체적인 클래스 사용

    public void addItem(String item) {
        items.add(item);
    }

    public ArrayList<String> getItems() {  // 반환 타입도 구체적인 클래스 사용
        return items;
    }
}
```

위 코드에서는 ArrayList를 구체적인 클래스 타입으로 사용하고 있으므로, 이후 LinkedList로 바꾸거나 List 인터페이스로 추상화하는 것이 어렵습니다.

**인터페이스로 참조한 좋은 예시:**

```java
public class ShoppingCart {
    private List<String> items = new ArrayList<>();  // 인터페이스 사용

    public void addItem(String item) {
        items.add(item);
    }

    public List<String> getItems() {  // 반환 타입도 인터페이스 사용
        return items;
    }
}
```

이 코드는 이후에 쉽게 ArrayList를 다른 List 구현체로 변경할 수 있습니다. 예를 들어, 동기화가 필요한 상황에서 CopyOnWriteArrayList로 교체할 수 있습니다.


**주의할 점:**
1. **인터페이스의 선택**

인터페이스로 참조할 때는 해당 객체의 가장 적합한 인터페이스를 선택해야 합니다. 예를 들어, List 인터페이스로 참조할 수 있지만, 객체가 특정한 이유로 Queue 인터페이스를 사용하는 것이 더 적합하다면 이를 사용하는 것이 좋습니다.

```java
Queue<String> queue = new LinkedList<>();  // Queue 인터페이스로 참조
```

2. **구체적인 클래스 사용이 불가피한 경우**

때로는 인터페이스 대신 구체적인 클래스가 더 적합할 수 있습니다. 예를 들어, 특정 라이브러리나 API에서 구체적인 클래스의 메서드를 사용할 필요가 있을 때는 구체적인 클래스를 사용해야 합니다. 그러나 이런 경우는 일반적으로 예외적인 상황으로 간주되어야 합니다.


**요약:**

• 객체를 참조할 때는 가능한 한 **구체적인 클래스 대신 인터페이스**로 참조해야 합니다. 이는 코드의 **유연성**과 **확장성**을 높이고, 유지보수와 테스트를 쉽게 만듭니다.

• 인터페이스를 사용하면 코드가 구현체에 종속되지 않으므로, 더 많은 구현체로 쉽게 교체할 수 있습니다.

• 멀티스레드 환경에서는 StringBuilder 대신 **StringBuffer**, List 대신 **CopyOnWriteArrayList** 같은 스레드 안전한 클래스 사용이 필요할 수 있습니다.

• 구체적인 클래스를 직접 사용하는 것은 그 클래스에 의존성을 강하게 만드는 일이므로, 특별한 이유가 없다면 인터페이스로 참조하는 것이 좋습니다.