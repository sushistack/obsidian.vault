 성능과 메모리 효율성, 그리고 코드의 명확성을 위해 자바에서 **기본형(primitive types)**을 가능한 한 **래퍼 클래스(boxed primitives)**보다 우선적으로 사용해야 한다는 것을 강조합니다.

자바는 기본형(int, long, double 등)과 이들을 감싸는 래퍼 클래스(Integer, Long, Double 등)를 제공하는데, 이 두 가지는 성능과 메모리 사용 측면에서 큰 차이를 보입니다. 기본형은 메모리를 적게 사용하고 성능이 빠른 반면, 래퍼 클래스는 객체로 다루어지기 때문에 메모리와 성능의 오버헤드가 발생합니다.

**주요 개념:**

  

1. **기본형(Primitive Types) vs 래퍼 클래스(Boxed Primitives)**

• **기본형(Primitive Types)**: 자바의 기본 데이터 타입으로, 값 자체를 저장하는 형식입니다. 기본형은 메모리를 효율적으로 사용하며 성능이 뛰어납니다.

• 예: int, long, float, double, boolean 등

• **래퍼 클래스(Boxed Primitives)**: 기본형을 객체로 감싸는 클래스입니다. 객체로 다루기 위해 사용되며, 컬렉션(List, Set, Map 등)이나 제네릭 같은 경우에는 반드시 래퍼 클래스를 사용해야 합니다.

• 예: Integer, Long, Float, Double, Boolean 등

```java
int primitiveInt = 42;        // 기본형
Integer boxedInt = 42;        // 래퍼 클래스
```

2. **기본형의 장점**

• **메모리 사용 효율**: 기본형은 값 자체를 저장하므로 래퍼 클래스보다 메모리 사용량이 적습니다. 래퍼 클래스는 객체로 처리되기 때문에 힙 영역에 추가적인 메모리가 할당됩니다.

• **성능**: 기본형은 객체 생성 오버헤드가 없기 때문에 연산 속도가 더 빠릅니다. 래퍼 클래스는 객체로 생성되고 해제되는 과정에서 성능 저하가 발생할 수 있습니다.

• **명확성**: 기본형은 값 자체를 직접 다루기 때문에 null 값이 존재하지 않아, NullPointerException 같은 오류가 발생하지 않습니다.

3. **래퍼 클래스의 단점**

• **오토박싱(Auto-boxing)과 언박싱(Unboxing) 비용**: 자바에서는 기본형과 래퍼 클래스 사이의 변환을 자동으로 처리해주는 **오토박싱**과 **언박싱** 기능이 있습니다. 기본형을 래퍼 클래스로 변환할 때는 오토박싱, 반대로 래퍼 클래스를 기본형으로 변환할 때는 언박싱이 일어납니다. 이는 추가적인 성능 비용을 초래할 수 있습니다.

```java
Integer boxedInt = 42;  // 오토박싱
int primitiveInt = boxedInt;  // 언박싱
```

• **null** **처리 문제**: 래퍼 클래스는 객체이기 때문에 null 값을 가질 수 있습니다. 만약 언박싱 과정에서 null이 발생하면 NullPointerException이 발생할 수 있어, 추가적인 null 체크가 필요합니다.

```java
Integer boxedInt = null;
int primitiveInt = boxedInt;  // NullPointerException 발생
```

4. **오토박싱과 언박싱의 성능 문제**

오토박싱과 언박싱이 빈번하게 일어나면 성능에 영향을 줄 수 있습니다. 특히, 반복문에서 기본형과 래퍼 클래스 간의 변환이 자주 일어나면 성능 저하가 두드러질 수 있습니다.

```java
// 오토박싱이 많이 발생하는 나쁜 예시
Integer sum = 0;
for (int i = 0; i < 100000; i++) {
    sum += i;  // 오토박싱과 언박싱이 반복됨
}
```

위 예시에서는 sum이 Integer로 선언되어 있으므로, 매번 덧셈 연산이 일어날 때마다 오토박싱과 언박싱이 발생합니다. 이는 불필요한 성능 손실을 초래할 수 있습니다.

**개선된 코드:**

```java
int sum = 0;  // 기본형 사용
for (int i = 0; i < 100000; i++) {
    sum += i;
}
```

여기서는 sum이 기본형 int로 선언되어, 오토박싱과 언박싱이 발생하지 않아 성능이 향상됩니다.

**언제 래퍼 클래스를 사용해야 하는가?**

1. **제네릭, 컬렉션 사용 시**

자바의 제네릭(Generic) 타입과 컬렉션(List, Set, Map 등)은 기본형을 사용할 수 없고, 반드시 래퍼 클래스를 사용해야 합니다. 이는 자바의 제네릭이 객체 참조만을 허용하기 때문입니다.

```java
List<Integer> numbers = new ArrayList<>();  // 기본형 int 대신 Integer 사용
```

이런 상황에서는 기본형을 사용할 수 없기 때문에 래퍼 클래스를 사용해야 합니다.

2. **객체로 다뤄야 할 때**

래퍼 클래스는 기본형 값을 객체로 다룰 수 있도록 해줍니다. 예를 들어, null 값이 필요한 경우나 객체로 다뤄야 하는 경우에는 래퍼 클래스를 사용할 수 있습니다.

```java
Integer boxedInt = null;  // 객체로서 null 값 표현 가능
```

그러나 null이 허용되는 상황에서도 가급적 Optional을 사용하는 것이 더 나은 선택일 수 있습니다. 예를 들어, OptionalInt, OptionalDouble 등의 기본형을 지원하는 Optional 클래스를 사용하는 것이 더 안전할 수 있습니다.

**래퍼 클래스 사용 시 주의사항:**

1. **null** **체크 필수**

래퍼 클래스는 null을 가질 수 있기 때문에, 언박싱하기 전에 반드시 null 체크를 해야 합니다. 그렇지 않으면 NullPointerException이 발생할 수 있습니다.

```java
Integer value = null;
if (value != null) {
    int primitiveValue = value;  // null 체크 후 언박싱
}
```

2. **오토박싱과 언박싱을 피하기 위한 주의**

반복문이나 계산 과정에서 불필요한 오토박싱과 언박싱이 발생하지 않도록 주의해야 합니다. 이는 성능에 영향을 줄 수 있으며, 특히 대량의 연산을 수행할 때는 성능 저하가 두드러질 수 있습니다.


**요약:**

• 가능한 한 **기본형(primitive types)**을 사용하고, **래퍼 클래스(boxed primitives)**는 필요한 경우에만 사용해야 합니다.
• 기본형은 메모리 효율이 높고 성능이 빠르며, null 값이 없어 NullPointerException이 발생할 가능성이 없습니다.
• 래퍼 클래스는 제네릭이나 컬렉션에서 필요하지만, 오토박싱과 언박싱에 따른 성능 비용과 null 처리 문제를 유의해야 합니다.
• 기본형을 사용하는 것이 적합한 상황에서는 항상 기본형을 선택하고, 래퍼 클래스를 사용할 때는 성능과 메모리 측면을 고려하여 신중하게 사용하는 것이 좋습니다.
