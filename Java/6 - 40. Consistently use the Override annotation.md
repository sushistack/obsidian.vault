자바에서 메서드를 오버라이드할 때 항상 **`@Override` 애노테이션**을 사용하는 것이 좋다

`@Override` 애노테이션은 메서드가 **슈퍼클래스 또는 인터페이스에서 상속된 메서드를 정확히 재정의(overriding)**하고 있음을 명시적으로 나타내며, 이는 코드의 **안전성**과 **가독성**을 크게 향상시킵니다.

### 1. 주제: **`@Override` 애노테이션을 일관되게 사용하는 이유**

자바에서 메서드를 오버라이드할 때 `@Override` 애노테이션을 사용하지 않으면, 의도적으로 작성된 코드라도 실수로 오버라이딩하지 않거나 오타로 인해 잘못된 메서드를 정의하는 경우가 발생할 수 있습니다. **`@Override` 애노테이션을 일관되게 사용하면** 컴파일러가 해당 메서드가 **정확하게 슈퍼클래스 또는 인터페이스의 메서드를 오버라이드하는지**를 확인해 주기 때문에 **오류를 예방**할 수 있습니다.

### 2. `@Override` 애노테이션을 사용하지 않은 경우의 문제점

#### (1) **오버라이드 실수**

슈퍼클래스의 메서드를 오버라이드할 때, 메서드 이름을 잘못 입력하거나 메서드 시그니처를 정확하게 일치시키지 않으면 **의도한 오버라이딩이 일어나지 않습니다**. 이 경우, **컴파일러가 오류를 잡아내지 못하고**, 런타임에서 의도와 다른 동작이 발생할 수 있습니다.

```java
public class Parent {
    public void doSomething() {
        System.out.println("Parent's doSomething");
    }
}

public class Child extends Parent {
    // 실수로 메서드 이름을 잘못 입력 (overide -> override)
    public void doSomthing() {
        System.out.println("Child's doSomething");
    }
}
```

위 코드에서 `Child` 클래스의 `doSomthing()` 메서드는 `Parent` 클래스의 `doSomething()` 메서드를 오버라이드하려고 했지만, **오타**로 인해 의도한 오버라이딩이 발생하지 않았습니다. 컴파일러는 이를 알아차리지 못하고, 런타임에서 의도와는 다른 동작을 하게 됩니다.

#### (2) **컴파일러의 도움 부족**

**`@Override` 애노테이션**이 없으면 **컴파일러가 해당 메서드가 슈퍼클래스의 메서드를 제대로 오버라이드하는지 확인할 수 없습니다**. 즉, 오버라이딩 여부를 개발자가 스스로 확인해야 하므로, 실수로 오버라이딩을 잘못한 경우에도 컴파일 오류가 발생하지 않습니다.

### 3. `@Override` 애노테이션을 사용한 경우

`@Override` 애노테이션을 사용하면, 컴파일러가 슈퍼클래스나 인터페이스의 메서드가 정확히 재정의되었는지 확인해 줍니다. 잘못된 오버라이드가 발생하면 **컴파일 타임에 오류를 감지**할 수 있어, 실수를 미리 방지할 수 있습니다.

```java
public class Parent {
    public void doSomething() {
        System.out.println("Parent's doSomething");
    }
}

public class Child extends Parent {
    @Override
    public void doSomething() {
        System.out.println("Child's doSomething");
    }
}
```

위 코드에서 `Child` 클래스의 `doSomething()` 메서드는 **정확히 오버라이드**되었으며, `@Override` 애노테이션 덕분에 컴파일러는 이 메서드가 상위 클래스의 메서드를 재정의하고 있음을 확인할 수 있습니다.

#### **오타가 있을 경우 컴파일 타임 오류**

만약 **오버라이딩을 의도했지만** 잘못된 메서드 시그니처를 사용했다면, `@Override` 애노테이션 덕분에 컴파일러가 이를 잡아냅니다.

```java
public class Child extends Parent {
    @Override
    public void doSomthing() {  // 오타 발생
        System.out.println("Child's doSomthing");
    }
}
```

이 코드는 **`doSomthing()`** 메서드가 잘못 정의되어 있기 때문에, 컴파일러는 **오버라이드가 올바르게 되지 않았음을** 알려줍니다. `@Override` 애노테이션을 사용하지 않았다면 이 오류는 **런타임에서만** 발견될 수 있었습니다.

### 4. 인터페이스 메서드 오버라이드 시 `@Override` 사용

**자바 6 이전**에는 **인터페이스**에서 상속된 메서드를 오버라이드할 때 **`@Override` 애노테이션을 사용할 수 없었지만**, 자바 6부터는 인터페이스 메서드를 재정의할 때도 `@Override` 애노테이션을 사용할 수 있습니다. 이는 **메서드 오버라이드의 일관성을 유지**하는 데 매우 중요합니다.

#### 예시:

```java
public interface Task {
    void execute();
}

public class MyTask implements Task {
    @Override
    public void execute() {
        System.out.println("Task executed");
    }
}
```

이처럼 인터페이스 메서드를 오버라이드할 때도 `@Override` 애노테이션을 사용하면, **컴파일러가 메서드 재정의를 올바르게 확인**해 주며, 실수를 방지할 수 있습니다.

### 5. `@Override` 사용의 장점

#### 1) **컴파일 타임 오류 감지**

**`@Override` 애노테이션**은 메서드 재정의에서 실수로 잘못된 메서드 이름이나 시그니처를 사용하는 경우, 컴파일러가 이를 **컴파일 타임에 오류로 감지**해 줍니다. 이를 통해 **런타임 오류를 예방**할 수 있습니다.

#### 2) **가독성 향상**

`@Override` 애노테이션을 사용하면 **해당 메서드가 상위 클래스나 인터페이스에서 상속된 메서드를 오버라이드하고 있음을 명확하게 보여줍니다**. 이는 **가독성**을 향상시키고, 코드를 쉽게 이해할 수 있게 도와줍니다.

#### 3) **유지보수성 향상**

메서드가 오버라이드된 것임을 명시적으로 표시하면, 유지보수 과정에서 실수로 메서드 시그니처를 변경하거나 잘못된 메서드를 정의하는 경우를 방지할 수 있습니다. 코드 변경 시 **일관성**을 유지하는 데 큰 도움이 됩니다.

#### 4) **리팩토링 안전성**

코드를 리팩토링할 때, **`@Override` 애노테이션이 적용된 메서드**는 상위 클래스나 인터페이스와의 관계를 명확하게 나타내기 때문에, **리팩토링 중 실수로 잘못된 수정**을 방지할 수 있습니다.

### 6. `@Override` 애노테이션을 일관되게 사용하는 모범 사례

- **모든 메서드 오버라이딩 시** `@Override` 애노테이션을 사용하는 것이 좋습니다. 이는 **슈퍼클래스**뿐만 아니라 **인터페이스의 메서드를 오버라이드할 때도 일관되게 적용**되어야 합니다.
    
- 오버라이드된 메서드가 **정확히 정의**되었는지 확인하기 위해, **컴파일러에게 오버라이드 여부를 명확하게 알리는** 좋은 방법입니다.
    

```java
public class Child extends Parent {
    @Override
    public void doSomething() {
        System.out.println("Child's doSomething");
    }

    // 인터페이스 메서드 오버라이드 시에도 사용
    @Override
    public void execute() {
        System.out.println("Executing task");
    }
}
```

### 7. 요약

- **`@Override` 애노테이션**은 메서드가 상위 클래스나 인터페이스의 메서드를 **재정의하고 있음을 명확히** 나타내고, 컴파일러가 이를 확인할 수 있게 해줍니다.
- **컴파일 타임에 오류를 감지**할 수 있어, 잘못된 오버라이드로 인한 런타임 오류를 예방할 수 있습니다.
- `@Override` 애노테이션을 사용하면 **가독성**, **유지보수성**, **리팩토링 안전성**이 크게 향상됩니다.
- **인터페이스 메서드를 오버라이드할 때도** `@Override` 애노테이션을 일관되게 사용하는 것이 좋습니다.

**결론적으로**, 메서드를 오버라이드할 때는 항상 **`@Override` 애노테이션을 사용하는 것이 바람직**합니다. 이를 통해 **코드의 안정성**과 **가독성**을 높이고, **오버라이드 실수**를 미리 방지할 수 있습니다.