클래스의 인스턴스 생성을 방지하기 위해 생성자를 private 으로 선언하는 방법, 주로 유틸리티 클래스나 정적 메서드 만을 제공하는 클래스에서 유용


### 1. 생성자를 private 으로 선언하는 이유

- **인스턴스 생성 방지**: 클래스의 생성자를 private으로 선언하면 외부에서 해당 클래스의 인스턴스를 생성할 수 없습니다. 이는 유틸리티 클래스나 정적 메서드만을 제공하는 클래스에서 중요합니다.
- **메모리 절약**: 불필요한 인스턴스 생성을 방지하여 메모리를 절약할 수 있습니다.
- **설계 의도 명확화**: 클래스가 인스턴스화되지 않도록 설계되었음을 명확히 할 수 있습니다.

### 2. 예제

```java
public class UtilityClass {
	// 생성자를 private으로 선언하여 인스턴스 생성을 방지합니다.
	private UtilityClass() {
		throw new AssertionError("This class cannot be instantiated");
	}

	// 정적 메서드 예제
	public static void usefulMethod() {
		// 유틸리티 메서드의 구현
	}
}
```

### 3. 주의사항

- **AssertionError 사용**: 생성자 내에서 `AssertionError`를 던지면, 실수로 인스턴스를 생성하려고 할 때 컴파일 타임이 아닌 런타임에 오류를 발생시킬 수 있습니다. 이는 클래스가 인스턴스화되지 않도록 설계되었음을 명확히 합니다.
- **직렬화 방지**: 클래스가 직렬화 가능하지 않도록 하려면 `Serializable` 인터페이스를 구현하지 않아야 합니다.

### 4. 장점

- **설계 의도 명확화**: 클래스가 인스턴스화되지 않도록 설계되었음을 명확히 할 수 있습니다.
- **메모리 절약**: 불필요한 인스턴스 생성을 방지하여 메모리를 절약할 수 있습니다.

### 5. 단점

- **런타임 오류**: 생성자 내에서 `AssertionError`를 던지는 방식은 컴파일 타임이 아닌 런타임에 오류를 발생시키므로, 실수로 인스턴스를 생성하려고 할 때 런타임 오류가 발생할 수 있습니다.

### 결론

생성자를 private 으로 선언하고 `AssertionError`를 던지는 방법은 유틸리티 클래스나 정적 메서드만을 제공하는 클래스에서 인스턴스 생성을 방지하는 데 유용합니다. 이를 통해 클래스의 설계 의도를 명확히 하고, 불필요한 인스턴스 생성을 방지할 수 있습니다.

