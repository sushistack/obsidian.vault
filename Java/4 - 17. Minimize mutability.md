클래스의 가변성(mutability)을 최소화하는 것이 중요한 이유와 방법

### 1. 가변성의 문제점

- **예측 불가능성**: 가변 객체는 상태가 변경될 수 있어, 예측하기 어렵습니다. 이는 디버깅과 유지보수를 어렵게 만듭니다.
- **스레드 안전성 문제**: 가변 객체는 여러 스레드에서 동시에 접근할 때 문제를 일으킬 수 있습니다. 이는 동기화 문제를 초래하고, 성능 저하를 일으킬 수 있습니다.
- **보안 문제**: 가변 객체는 외부에서 쉽게 변경될 수 있어, 보안 문제를 일으킬 수 있습니다.
- **불변성 유지 어려움**: 가변 객체는 불변성을 유지하기 어렵습니다. 이는 객체의 상태가 변경될 때마다 새로운 객체를 생성해야 하는 경우가 많습니다.

### 2. 불변성의 장점

- **예측 가능성**: 불변 객체는 상태가 변경되지 않으므로, 예측하기 쉽습니다. 이는 디버깅과 유지보수를 용이하게 합니다.
- **스레드 안전성**: 불변 객체는 여러 스레드에서 동시에 접근해도 안전합니다. 이는 동기화 문제를 피하고, 성능을 향상시킬 수 있습니다.
- **보안**: 불변 객체는 외부에서 변경될 수 없으므로, 보안이 강화됩니다.
- **불변성 유지**: 불변 객체는 불변성을 유지하기 쉽습니다. 이는 객체의 상태가 변경되지 않으므로, 새로운 객체를 생성할 필요가 없습니다.

### 3. 불변성을 유지하는 방법

- **final 키워드 사용**: 클래스와 필드를 `final`로 선언하여 변경을 방지합니다.
- **접근자 메서드 제공**: 필드를 `private`으로 선언하고, 게터(getter) 메서드만 제공하여 외부에서 필드를 변경할 수 없도록 합니다.
- **불변 객체 사용**: 불변 객체를 사용하여 상태를 변경할 수 없도록 합니다. 예를 들어, `String`, `Integer`, `BigDecimal` 등의 불변 객체를 사용합니다.
- **방어적 복사**: 가변 객체를 받을 때, 방어적 복사(defensive copy)를 사용하여 내부 상태를 보호합니다.

### 4. 예제

```java
public final class ImmutablePoint {  
    private final int x;  
    private final int y;  
  
    public ImmutablePoint(int x, int y) {  
        this.x = x;  
        this.y = y;  
    }  
  
    public int getX() {  
        return x;  
    }  
  
    public int getY() {  
        return y;  
    }  
  
    @Override  
    public String toString() {  
        return "ImmutablePoint{" +  
                "x=" + x +  
                ", y=" + y +  
                '}';  
    }  
}
```

### 5. 주의사항

- **성능 고려**: 불변 객체를 사용하면 새로운 객체를 생성해야 하는 경우가 많습니다. 이는 성능에 영향을 미칠 수 있습니다.
- **과도한 불변성**: 모든 객체를 불변으로 만드는 것은 불필요할 수 있습니다. 필요한 경우에만 불변성을 유지해야 합니다.
- **상속 문제**: 불변 클래스는 상속이 불가능합니다. 이는 클래스의 확장성을 제한할 수 있습니다.

### 6. 결론

클래스의 가변성을 최소화하는 것은 예측 가능성, 스레드 안전성, 보안, 불변성 유지 등의 장점을 제공합니다. 불변성을 유지하기 위해 `final` 키워드를 사용하고, 접근자 메서드를 제공하며, 불변 객체를 사용하고, 방어적 복사를 사용하는 것이 중요합니다. 이를 통해 코드의 안정성과 유지보수성을 높일 수 있습니다. 그러나 성능과 과도한 불변성, 상속 문제 등을 고려하여 적절히 사용해야 합니다.