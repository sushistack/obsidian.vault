메서드 오버로딩(Method Overloading)을 신중하게 사용해야 한다는 것을 강조합니다. 

오버로딩은 같은 이름을 가지는 여러 메서드를 정의하되, 매개변수의 타입이나 개수를 다르게 하는 기법입니다. 잘 설계된 오버로딩은 코드의 가독성을 높이고 재사용성을 강화하지만, 잘못된 오버로딩은 혼란을 야기하고 오류를 유발할 수 있습니다.

**주요 개념:**

1. **오버로딩과 오버라이딩의 차이**

오버로딩은 동일한 클래스 내에서 같은 이름의 메서드를 여러 개 정의하는 것이고, 오버라이딩(Overriding)은 상위 클래스의 메서드를 하위 클래스에서 재정의하는 것입니다. 두 개념이 헷갈릴 수 있지만, 오버로딩은 매개변수의 시그니처를 다르게 정의하는 것이 핵심입니다.

2. **오버로딩의 문제점**

자바의 메서드 선택은 **컴파일 타임**에 결정됩니다. 따라서 오버로딩된 메서드는 호출 시 매개변수의 **정확한 타입**에 따라 달라지는데, 이때 기대와 다른 메서드가 호출될 수 있습니다. 특히, 상속 구조에서 null이나 상위 타입을 인자로 전달할 때, 메서드 선택이 직관적이지 않은 상황이 자주 발생할 수 있습니다.

• 예를 들어, 기본 타입과 객체 타입(int vs Integer)을 혼용할 때, 의도하지 않은 메서드가 호출될 수 있습니다.

3. **혼란을 피하기 위한 대안**

오버로딩 대신, 메서드 이름을 명확히 다르게 설정하여 각 메서드의 역할이 명확하도록 할 수 있습니다. 이런 방식으로 오버로딩이 주는 혼란을 줄일 수 있습니다.

4. **varargs 사용의 주의점**

가변 인자(Varargs)를 사용하여 여러 개의 인수를 처리할 수 있지만, varargs가 오버로딩과 함께 사용되면 호출 시점에 어떤 메서드가 선택될지 예측하기 어려워질 수 있습니다. 이는 성능과 안전성 면에서 문제가 될 수 있습니다.

  

**예시:**

**예시 1: 잘못된 오버로딩**

```java
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    public double add(double a, double b) {
        return a + b;
    }
}

public class Main {
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        System.out.println(calc.add(1, 2));        // int 메서드 호출
        System.out.println(calc.add(1.0, 2.0));    // double 메서드 호출
        System.out.println(calc.add(1, 2.0));      // 컴파일 오류: 혼란스러운 오버로딩
    }
}
```

위 예시에서 int와 double 타입의 혼합된 경우가 발생하면, 컴파일러가 어떤 메서드를 선택할지 혼란스러워할 수 있습니다. 이렇게 오버로딩은 명확하지 않은 상황을 만들 수 있습니다.

**예시 2: 오버로딩을 피하는 방법**

```java
public class Calculator {
    public int addIntegers(int a, int b) {
        return a + b;
    }

    public double addDoubles(double a, double b) {
        return a + b;
    }
}

public class Main {
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        System.out.println(calc.addIntegers(1, 2));   // 명확한 메서드 호출
        System.out.println(calc.addDoubles(1.0, 2.0)); // 명확한 메서드 호출
    }
}
```

이 방식에서는 메서드 이름을 다르게 하여 메서드의 역할을 명확하게 구분할 수 있습니다. 이로써 컴파일러와 사용자가 혼란스러워할 가능성을 줄였습니다.

  

**주의할 점:**

1. **매개변수 타입의 불명확성**

메서드 오버로딩은 매개변수의 타입에 따라 메서드가 선택되므로, 유사한 매개변수 타입이 있을 때 혼란을 일으킬 수 있습니다. 예를 들어 int와 long 타입을 혼용하면, 자동 형변환(autoboxing)이 개입하여 예상치 못한 메서드가 호출될 수 있습니다.

2. **상속 계층에서의 오버로딩**

상속 계층 구조에서 부모 클래스의 메서드를 오버로딩하면, 자식 클래스에서 그 메서드를 호출할 때 상위 클래스의 메서드와 구분이 어려워질 수 있습니다. 이런 경우, 오버로딩 대신 메서드 이름을 다르게 설정하는 것이 좋습니다.

3. **오버로딩된 메서드 선택은 컴파일 타임에 결정**

오버로딩된 메서드는 런타임이 아닌 컴파일 타임에 어떤 메서드를 호출할지 결정됩니다. 따라서 컴파일러는 인자의 정적 타입을 기반으로 메서드를 선택하며, 예상치 못한 메서드가 호출될 수 있습니다.

4. **Varargs와 오버로딩을 함께 사용 시 주의**

Varargs는 여러 인수를 처리할 수 있어 유용하지만, 오버로딩과 함께 사용할 때는 주의해야 합니다. 가변 인자 메서드는 다른 오버로딩된 메서드와의 충돌을 일으킬 수 있으며, 이로 인해 호출된 메서드를 쉽게 오해할 수 있습니다.

```java
public void print(String s) {
    System.out.println(s);
}

public void print(String... s) {
    for (String str : s) {
        System.out.println(str);
    }
}

public static void main(String[] args) {
    print("Hello"); // 어떤 메서드가 호출될까요? Varargs와의 충돌 가능성.
}
```

위와 같은 경우 varargs 메서드가 오버로딩된 다른 메서드를 덮어쓸 수 있어 예기치 않은 결과를 초래할 수 있습니다.

**요약:**

• 오버로딩을 사용할 때는 혼란을 방지하기 위해 메서드 이름을 명확히 구분하거나 불필요한 오버로딩을 피해야 합니다.
• 메서드 시그니처가 매우 유사하거나 애매한 타입들(int, long, float, double)을 사용하는 경우, 오버로딩은 혼란을 일으킬 수 있습니다.
• 오버로딩된 메서드는 컴파일 타임에 결정되므로 호출하는 인자의 타입에 주의해야 합니다.
• 가급적 오버로딩 대신, 명확한 메서드 이름으로 메서드를 구분하는 것이 좋습니다.
• Varargs와 오버로딩을 함께 사용할 때는 메서드 충돌이 발생할 수 있으므로 주의해야 합니다.

