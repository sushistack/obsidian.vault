**마커 인터페이스(marker interface)**를 사용하여 **특정 타입을 정의하거나 특정 클래스의 능력을 명시적으로 표시**하는 기법

**마커 인터페이스**는 메서드를 가지지 않고, **빈 인터페이스**를 구현함으로써 클래스가 특정 타입의 일부임을 나타냅니다. 마커 인터페이스는 **타입 정의**와 **컴파일 타임 타입 검사**를 제공하는 데 유용하며, **애노테이션(annotation)**과 함께 사용할 수 있지만, 특정 상황에서는 **마커 인터페이스**가 더 적합한 선택이 될 수 있습니다.

### 1. 주제: **마커 인터페이스를 사용하여 타입을 정의하는 이유**

**마커 인터페이스**는 클래스에 **메서드나 필드 없이** 특정한 **의미나 역할을 부여**할 수 있습니다. 이를 통해 **컴파일 타임에 타입 안정성을 유지**할 수 있으며, 해당 클래스가 특정 능력을 갖췄음을 나타낼 수 있습니다. 마커 인터페이스는 **타입을 정의**하는 데 강력한 도구이며, **특정 타입의 객체를 구분**하고, **타입 안전성을 제공**하며, 코드에서의 **일관성**을 유지하는 데 도움이 됩니다.

### 2. 마커 인터페이스의 개념

#### (1) **마커 인터페이스의 정의**

**마커 인터페이스(marker interface)**는 **메서드를 포함하지 않는 빈 인터페이스**로, 특정 클래스가 해당 인터페이스를 구현하면, 그 클래스는 **특정 역할이나 능력을 가진 타입**으로 간주됩니다. 자바의 몇 가지 대표적인 마커 인터페이스는 다음과 같습니다:

- **`Serializable`**: 클래스가 이 인터페이스를 구현하면 해당 클래스의 인스턴스가 **직렬화 가능**함을 나타냅니다.
- **`Cloneable`**: 클래스가 이 인터페이스를 구현하면 해당 클래스의 인스턴스는 **`clone()` 메서드를 호출할 수 있음**을 나타냅니다.

#### (2) **마커 인터페이스의 목적**

마커 인터페이스는 주로 **타입의 일관성을 유지**하고, 클래스가 특정 동작을 수행할 수 있다는 것을 **명시적으로 나타내기 위한 용도**로 사용됩니다. 또한, **타입 시스템**을 통해 **컴파일 타임에 타입 안전성**을 제공하는 중요한 역할을 합니다.

### 3. 마커 인터페이스의 사용 예시

#### (1) **`Serializable` 마커 인터페이스**

`Serializable` 인터페이스는 자바에서 매우 잘 알려진 **마커 인터페이스**로, 클래스가 이를 구현하면 해당 클래스의 인스턴스를 **직렬화 가능**하게 만듭니다.

```java
import java.io.Serializable;

public class Person implements Serializable {
    private String name;
    private int age;

    // 생성자와 getter/setter 생략
}
```

위 예시에서 `Person` 클래스는 `Serializable` 인터페이스를 구현함으로써 **직렬화 가능**한 객체가 됩니다. 자바의 **객체 직렬화** 메커니즘은 `Serializable`을 구현한 클래스만 직렬화할 수 있습니다.

#### (2) **`Cloneable` 마커 인터페이스**

`Cloneable` 마커 인터페이스는 클래스가 이를 구현하면 **`Object.clone()`** 메서드를 호출할 수 있도록 허용합니다.

```java
public class Employee implements Cloneable {
    private String name;
    private int id;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```

위 코드에서 `Employee` 클래스는 `Cloneable`을 구현하여 객체를 **클론**할 수 있는 능력을 갖추게 됩니다. **`clone()`** 메서드는 `Cloneable`을 구현하지 않은 클래스에서 호출하면 **`CloneNotSupportedException`**이 발생합니다.

### 4. 마커 인터페이스 vs 애노테이션

자바에서 **애노테이션**은 **메타데이터**를 표현할 수 있는 강력한 도구이며, 마커 인터페이스와 유사한 역할을 할 수 있습니다. 예를 들어, 애노테이션도 클래스에 특정 의미를 부여할 수 있습니다. 하지만 특정한 경우 **마커 인터페이스**가 애노테이션보다 적합할 수 있습니다.

#### (1) **타입 시스템의 이점**

마커 인터페이스는 **타입 시스템**에 통합되어 **타입 안전성**을 제공합니다. 즉, 마커 인터페이스를 구현한 객체는 해당 타입으로 취급되며, **컴파일 타임에 타입 체크**가 가능합니다. 반면, **애노테이션**은 런타임에 주로 해석되며, **컴파일 타임에 타입 안전성을 제공하지 않습니다**.

예시:

```java
public interface Auditable {}

public class Document implements Auditable {
    // 문서 처리 로직
}

public void processAudit(Auditable auditable) {
    // 감사 처리 로직
}

Document doc = new Document();
processAudit(doc);  // Auditable을 구현한 클래스만 허용

```

위 코드에서 `processAudit` 메서드는 `Auditable` 인터페이스를 구현한 클래스만 처리할 수 있으므로, **컴파일 타임에 타입 안전성**이 보장됩니다.

#### (2) **의미적 차이**

마커 인터페이스는 **클래스가 특정 타입임을 명시적으로 선언**합니다. 이는 해당 클래스가 특정 동작을 수행할 수 있다는 의미를 가지며, **역할에 대한 일관성을 유지**합니다. 반면, 애노테이션은 단순히 **메타데이터**를 제공하는 역할에 그칠 수 있습니다.

### 5. 마커 인터페이스의 장점

#### 1) **타입 안전성 제공**

마커 인터페이스는 타입 시스템에 통합되어 **컴파일 타임에 타입 안전성을 보장**합니다. 이는 특정 메서드가 마커 인터페이스를 구현한 클래스만 처리하도록 강제할 수 있기 때문에, **잘못된 타입 사용**으로 인한 오류를 방지할 수 있습니다.

#### 2) **가독성 및 명확성**

마커 인터페이스를 구현함으로써, 해당 클래스가 **어떤 역할을 수행할 수 있는지** 명확하게 표현할 수 있습니다. 이를 통해 코드의 **가독성**과 **유지보수성**이 향상됩니다.

#### 3) **프레임워크에서의 유용성**

마커 인터페이스는 여러 **자바 프레임워크**에서 널리 사용됩니다. 특정 클래스가 **특정 기능을 지원하는지**를 마커 인터페이스로 쉽게 구분할 수 있습니다. 예를 들어, 자바의 **직렬화(serialization)** 메커니즘은 `Serializable`을 구현한 클래스만 직렬화할 수 있으며, 이는 프레임워크에서 일관된 동작을 보장하는 데 매우 유용합니다.

### 6. 마커 인터페이스 사용 예시

#### (1) **권한 관리 시스템에서의 마커 인터페이스 사용**

권한 관리 시스템에서는 **마커 인터페이스**를 사용해 특정 역할을 명시할 수 있습니다.

```java
public interface AdminRole {}

public class AdminUser implements AdminRole {
    private String username;
    // Admin 사용자 관련 로직
}

public class User {
    private String username;
    // 일반 사용자 관련 로직
}

public class AccessControl {
    public void grantAdminAccess(AdminRole admin) {
        // 관리자에게만 권한을 부여하는 로직
    }
}
```

위 코드에서 **`AdminRole`** 마커 인터페이스는 **관리자 역할을 가진 사용자**만 `grantAdminAccess` 메서드에 전달될 수 있음을 보장합니다. 이를 통해 타입 안전하게 **특정 역할을 수행할 수 있는 객체**를 처리할 수 있습니다.

#### (2) **플러그인 시스템에서의 마커 인터페이스 사용**

플러그인 시스템에서도 마커 인터페이스를 사용하여 플러그인을 정의할 수 있습니다.

```java
public interface Plugin {}

public class MyPlugin implements Plugin {
    public void execute() {
        System.out.println("Plugin executed");
    }
}

public class PluginManager {
    public void loadPlugin(Plugin plugin) {
        plugin.execute();
    }
}
```

위 코드에서 `Plugin` 마커 인터페이스를 구현한 클래스는 플러그인으로 간주되며, 플러그인 매니저는 **`Plugin` 타입만 허용**하여 일관된 처리를 보장합니다.

### 7. 요약

- **마커 인터페이스**는 **메서드가 없는 빈 인터페이스**로, 특정 클래스를 **타입 시스템**에서 특정 역할로 분류하거나 특정 기능을 할 수 있도록 나타냅니다.
- **타입 안전성**을 제공하며, **컴파일 타임**에 타입 검사를 통해 오류를 방지할 수 있습니다.
- **애노테이션**은 메타데이터를 표현할 때 유용하지만, **마커 인터페이스**는 타입을 정의하고 **컴파일 타임에 타입을 명확히 구분**하는 데 더 적합합니다.
- 마커 인터페이스는 자바에서 **`Serializable`, `Cloneable`**과 같은 표준 인터페이스로 널리 사용되며, **타입 안전한 설계**를 가능하게 합니다.

**결론적으로**, 특정 클래스가 **특정 역할을 수행할 수 있는 타입**임을 나타낼 때, **마커 인터페이스**를 사용하는 것은 **타입 안전성을 보장**하고 **코드의 명확성**을 높이는 강력한 도구입니다.