**병렬 스트림(parallel streams)**을 사용할 때 발생할 수 있는 문제점과 주의해야 할 사항

**병렬 스트림**은 데이터를 **병렬로 처리**하여 성능을 개선할 수 있는 강력한 도구이지만, 모든 경우에 적합하지 않으며, 부주의하게 사용할 경우 성능 저하나 **동시성 문제**가 발생할 수 있습니다. 병렬 스트림을 사용할 때는 **데이터 크기**, **작업의 복잡성**, **병렬화에 따른 오버헤드**를 고려해야 합니다.

### 1. 주제: **병렬 스트림 사용 시 주의해야 하는 이유**

병렬 스트림은 **데이터를 여러 스레드로 분할**하여 병렬로 처리하기 때문에 **대규모 데이터 처리**에서 성능을 개선할 수 있습니다. 하지만 잘못된 상황에서 사용하거나 병렬 처리에 적합하지 않은 작업에 병렬 스트림을 적용하면 **성능 저하**나 **오류**가 발생할 수 있습니다. 따라서 병렬 스트림을 사용할 때는 **신중한 판단**이 필요합니다.

### 2. 병렬 스트림의 작동 방식

병렬 스트림은 데이터를 **분할**하여 여러 **스레드에서 병렬로 처리**합니다. 자바의 병렬 스트림은 **ForkJoinPool**을 사용하여 작업을 처리하며, 데이터를 작은 단위로 분할한 후 각 스레드에서 처리한 결과를 다시 합치는 방식으로 동작합니다. **병렬 처리**는 일반적으로 **CPU 코어 수**에 비례하여 성능을 향상시킬 수 있지만, **병렬화에 따른 오버헤드**나 **병렬 처리에 적합하지 않은 작업**이 있을 수 있습니다.

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");

// 병렬 스트림을 사용한 데이터 처리
names.parallelStream()
    .forEach(System.out::println);
```

위 코드는 **병렬 스트림**을 사용하여 이름 리스트의 각 요소를 병렬로 출력합니다. 병렬 스트림을 사용할 때는 **데이터의 크기**, **처리할 작업의 성격**, **환경 설정**을 고려해야 합니다.

### 3. 병렬 스트림 사용 시 주의해야 할 사항

#### (1) **작업의 성격에 따라 병렬 처리의 적합성 결정**

병렬 스트림은 **독립적이고, 부수 효과가 없는 작업**에 적합합니다. 하지만 **순차적인 의존성**이 있는 작업이나 **상태를 변경**하는 작업에서는 병렬 스트림을 사용할 경우 문제가 발생할 수 있습니다. 예를 들어, **상태를 공유**하거나 **부수 효과가 있는 함수**를 병렬로 처리하면 **경합 조건**이나 **데이터 불일치** 문제가 발생할 수 있습니다.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
List<Integer> results = new ArrayList<>();

// 병렬 스트림에서 외부 상태를 변경하는 코드 (비추천)
numbers.parallelStream()
    .forEach(n -> results.add(n * 2));  // 경합 조건 발생 가능

System.out.println(results);
```

위 코드에서 `results` 리스트는 여러 스레드에서 동시에 수정되기 때문에 **경합 조건**이 발생할 수 있습니다. 이러한 문제를 피하기 위해 **부수 효과가 없는 함수**를 사용하는 것이 중요합니다.

#### (2) **병렬화의 오버헤드 고려**

병렬 스트림은 **작업 분할과 병합** 과정에서 **오버헤드**가 발생합니다. 데이터 크기가 작거나 작업이 간단한 경우, 병렬화로 인한 오버헤드가 성능 향상을 무색하게 할 수 있습니다. 즉, **작은 데이터셋**이나 **가벼운 작업**에 병렬 스트림을 사용하는 것은 오히려 성능을 저하시킬 수 있습니다.

```java
List<Integer> smallList = Arrays.asList(1, 2, 3, 4);

// 작은 리스트에 병렬 스트림을 사용하는 것은 비효율적일 수 있음
smallList.parallelStream()
    .map(n -> n * 2)
    .forEach(System.out::println);
```

위 코드처럼 **작은 리스트**에서는 병렬 스트림의 오버헤드가 병렬 처리의 성능 이점을 상쇄할 수 있으므로, **순차 스트림**을 사용하는 것이 더 나을 수 있습니다.

#### (3) **데이터 소스의 특성 고려**

병렬 스트림을 사용할 때 **데이터 소스**가 병렬 처리에 적합한지 고려해야 합니다. 예를 들어, **ArrayList**와 같은 **순차 접근이 가능한 자료구조**는 병렬 스트림에서 좋은 성능을 발휘할 수 있지만, **LinkedList**와 같은 **연결 리스트**는 병렬로 처리하기에 적합하지 않습니다. 또한, **배열**과 같은 데이터 구조는 병렬 처리에 더 효율적입니다.

```java
// ArrayList는 병렬 스트림에서 좋은 성능을 발휘할 수 있음
List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
numbers.parallelStream()
    .map(n -> n * 2)
    .forEach(System.out::println);
```

위 코드에서 **`ArrayList`**는 **병렬 처리에 최적화된 자료구조**이므로 병렬 스트림을 사용하는 것이 적합할 수 있습니다. 반면, **LinkedList**는 순차적인 접근이 더 적합합니다.

#### (4) **적절한 스레드 풀 설정**

자바의 병렬 스트림은 **ForkJoinPool**을 사용하여 작업을 처리합니다. 기본적으로 **CPU 코어 수**에 맞게 **스레드 풀**이 설정되지만, 필요에 따라 **스레드 풀 크기**를 조정할 수 있습니다. 병렬 스트림을 사용할 때 **스레드 풀 크기**를 적절히 조정하지 않으면 **과도한 스레드 사용**으로 성능이 저하될 수 있습니다.

```java
System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism", "4");

List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
numbers.parallelStream()
    .forEach(System.out::println);
```

위 코드처럼 **ForkJoinPool의 병렬성 수준**을 설정하여 스레드 수를 조정할 수 있습니다. 하지만 이를 잘못 설정하면 **과도한 스레드 생성**으로 인해 오히려 성능이 떨어질 수 있습니다.

#### (5) **데드락(Deadlock) 위험**

병렬 스트림에서 **공유 자원**을 사용할 경우 **데드락**이 발생할 수 있습니다. 특히 **병렬 스트림 내부에서 동기화된 코드**를 사용할 때는 주의해야 합니다.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4);

synchronized (numbers) {
    numbers.parallelStream().forEach(System.out::println);  // 데드락 발생 가능
}
```

위 코드는 **병렬 스트림**과 **동기화된 블록**이 함께 사용되어 **데드락**이 발생할 수 있습니다. 병렬 스트림을 사용할 때는 **동기화된 자원**을 피하는 것이 좋습니다.

### 4. 병렬 스트림이 적합한 경우

#### (1) **대규모 데이터 처리**

병렬 스트림은 대규모 데이터셋을 처리할 때 성능을 크게 향상시킬 수 있습니다. 데이터 크기가 클수록 **병렬 처리의 이점**이 커지며, 처리 시간이 크게 단축될 수 있습니다.

```java
List<Integer> largeList = IntStream.range(0, 1_000_000).boxed().collect(Collectors.toList());

// 대규모 데이터셋에 병렬 스트림 사용
largeList.parallelStream()
    .map(n -> n * 2)
    .forEach(System.out::println);
```

위 코드는 **대규모 리스트**를 병렬로 처리하여 성능을 극대화합니다.

#### (2) **독립적인 작업 처리**

각 요소가 독립적으로 처리되는 경우 병렬 스트림을 사용하는 것이 적합합니다. **의존성이 없고 부수 효과가 없는 작업**은 병렬 스트림에서 최상의 성능을 발휘할 수 있습니다.

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

// 독립적인 데이터 처리 작업
names.parallelStream()
    .map(String::toUpperCase)
    .forEach(System.out::println);
```

위 코드는 각 요소가 독립적으로 처리되므로 **병렬 스트림을 안전하게 사용**할 수 있습니다.

### 5. 요약

- **병렬 스트림**은 대규모 데이터 처리에서 성능을 향상시킬 수 있지만, **부주의하게 사용하면 성능 저하**나 **동시성 문제**가 발생할 수 있습니다.
- 병렬 스트림을 사용할 때는 **작업의 독립성**, **데이터 소스의 특성**, **병렬화 오버헤드**를 신중하게 고려해야 합니다.
- **작은 데이터셋**이나 **간단한 작업**에는 병렬 스트림을 사용하는 것이 오히려 성능을 저하시킬 수 있습니다.
- 병렬 스트림에서 **외부 상태를 변경하거나** **동기화된 자원**을 사용하는 것은 피해야 합니다.
- 병렬 스트림은 **대규모 데이터**나 **독립적인 작업**을 처리할 때 가장 적합합니다.

**결론적으로**, **병렬 스트림을 사용할 때는 신중하게 판단**하고, 데이터 크기와 작업의 특성에 따라 **순차 스트림과 병렬 스트림을 적절히 선택**하는 것이 중요합니다.