**람다 표현식(Lambda expressions)**을 사용할 수 있을 때는 **익명 클래스(Anonymous classes)** 대신 **람다**를 사용하는 것이 더 나은 선택이라는 것을 강조

람다는 **간결하고 가독성이 높으며** 코드의 **유지보수성**을 향상시키는 데 매우 유용합니다. 자바 8부터 도입된 **람다**는 특히 **함수형 인터페이스(functional interface)**와 함께 사용할 때 익명 클래스보다 더 깔끔하고 효율적인 코드 작성을 가능하게 합니다.

### 1. 주제: **익명 클래스 대신 람다를 사용하는 이유**

**익명 클래스**는 자바에서 자주 사용되어 왔지만, **보일러플레이트 코드**가 많고 **가독성이 떨어지는 문제**가 있습니다. **람다**는 익명 클래스를 대체할 수 있는 더 간결한 방식으로, **함수형 인터페이스**를 구현하는 경우 특히 유용합니다. 익명 클래스는 여전히 사용할 수 있지만, **람다가 더 간단하고 명확한 대안**이 될 수 있습니다.

### 2. 익명 클래스 사용의 문제점

#### (1) **익명 클래스의 예시**

익명 클래스는 이름이 없는 클래스를 정의하여 **즉석에서 사용**하는 방식으로, 주로 **이벤트 리스너**나 **콜백 함수** 등의 작업에 사용됩니다. 자바 8 이전에는 익명 클래스가 이러한 작업을 처리하는 유일한 방법이었습니다.

```java
// 익명 클래스 사용
Button button = new Button();
button.setOnClickListener(new OnClickListener() {
    @Override
    public void onClick(View v) {
        System.out.println("Button clicked!");
    }
});
```

위 코드는 익명 클래스를 사용하여 **버튼 클릭 이벤트**를 처리하고 있습니다. 하지만, 이 코드는 **많은 보일러플레이트 코드**를 포함하고 있으며, **중첩된 코드 구조**로 인해 가독성이 떨어집니다. 특히 코드의 중요한 부분인 `onClick` 메서드가 코드의 하위에 묻혀서 잘 보이지 않습니다.

#### (2) **가독성 문제**

익명 클래스는 **내부적으로 상위 클래스나 인터페이스를 구현**하는 방식이지만, 코드가 복잡해지고 중첩될 경우 **가독성**이 떨어집니다. 또한, **`this` 키워드**가 익명 클래스 내부에서 어떻게 동작하는지 혼란을 줄 수 있으며, **상태를 관리**하기 어렵습니다.

### 3. 람다 표현식의 장점

람다 표현식은 **익명 클래스**와 같은 용도로 사용할 수 있지만, 코드가 **더 간결하고 명확**해집니다. 자바 8 이후에는 **함수형 인터페이스**를 구현할 때 익명 클래스 대신 람다를 사용하는 것이 **추천되는 방식**입니다.

#### (1) **람다 표현식을 사용하는 방식**

람다 표현식은 **익명 함수**를 간단하게 정의하는 방법으로, 함수형 인터페이스와 함께 사용됩니다. **함수형 인터페이스**는 단 하나의 추상 메서드를 가지는 인터페이스로, `@FunctionalInterface`로 선언됩니다.

```java
// 람다 표현식 사용
Button button = new Button();
button.setOnClickListener(v -> System.out.println("Button clicked!"));
```

위 코드에서 익명 클래스 대신 **람다 표현식**을 사용하면, 코드가 훨씬 **간결**해지고 **가독성**이 높아집니다. **람다**는 `OnClickListener` 인터페이스의 단일 메서드인 `onClick()`을 구현합니다. 중요한 로직인 **`System.out.println()`**이 **명확하게 드러납니다**.

#### (2) **간결한 코드**

람다 표현식을 사용하면 **필요 없는 보일러플레이트 코드**를 제거할 수 있습니다. 익명 클래스에 비해 코드가 훨씬 짧고, 불필요한 코드가 없기 때문에 **가독성**이 매우 높아집니다.

```java
// 익명 클래스 예시
Runnable r1 = new Runnable() {
    @Override
    public void run() {
        System.out.println("Hello, World!");
    }
};

// 람다 표현식 예시
Runnable r2 = () -> System.out.println("Hello, World!");
```

위 예시에서, 람다 표현식은 익명 클래스에 비해 훨씬 간결하며, 핵심 로직이 더 명확하게 드러납니다.

### 4. 람다의 추가 장점

#### (1) **타입 추론**

람다 표현식은 **타입 추론**을 지원합니다. 자바 컴파일러가 **컨텍스트**에서 타입을 추론할 수 있으므로, 개발자가 타입을 명시적으로 선언할 필요가 없습니다.

```java
// 타입 추론 덕분에 간결한 코드
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
names.forEach(name -> System.out.println(name));
```

위 코드에서 `name`의 타입을 명시할 필요가 없으며, **컴파일러가 자동으로 타입을 추론**합니다.

#### (2) **람다 표현식은 캡처링(capturing)을 지원**

람다 표현식은 **로컬 변수를 캡처**할 수 있습니다. 이는 **익명 클래스**와 동일하지만, 람다 표현식은 **`this` 키워드**의 동작이 더 직관적입니다. 익명 클래스 내부의 `this`는 익명 클래스 자체를 가리키지만, 람다 표현식에서는 **외부 객체를 그대로 참조**합니다.

```java
public class MyClass {
    public void doSomething() {
        String message = "Hello";
        Runnable r = () -> System.out.println(message);  // 로컬 변수 캡처
        r.run();
    }
}
```

람다는 **외부 변수**를 캡처할 수 있으며, **가독성이 높은 코드**를 작성하는 데 도움을 줍니다.

### 5. 익명 클래스가 여전히 유용한 경우

익명 클래스가 **람다로 대체할 수 없는 경우**도 존재합니다. 람다는 **함수형 인터페이스**만 구현할 수 있지만, **익명 클래스**는 **복수의 메서드를 가진 클래스**를 확장하거나 **인터페이스를 구현**할 수 있습니다.

#### (1) **메서드를 여러 개 오버라이드해야 하는 경우**

```java
// 익명 클래스를 사용하여 여러 메서드를 오버라이드
WindowAdapter windowAdapter = new WindowAdapter() {
    @Override
    public void windowOpened(WindowEvent e) {
        System.out.println("Window opened");
    }

    @Override
    public void windowClosing(WindowEvent e) {
        System.out.println("Window closing");
    }
};
```

익명 클래스는 **복수의 메서드를 오버라이드**할 때 여전히 유용합니다. 이런 경우에는 **람다로 대체할 수 없습니다**.

#### (2) **상태를 저장해야 하는 경우**

익명 클래스는 **상태를 저장**할 수 있지만, 람다는 **불변**이기 때문에 상태를 저장해야 하는 경우에는 익명 클래스를 사용해야 합니다.

```java
int counter = 0;
Runnable r = new Runnable() {
    @Override
    public void run() {
        System.out.println("Counter: " + counter);
    }
};
```

람다 표현식은 **상태를 변경할 수 없기 때문에** 이런 경우 익명 클래스를 사용해야 합니다.

### 6. 요약

- **람다 표현식**은 함수형 인터페이스를 간결하고 가독성 좋게 구현할 수 있는 강력한 도구로, **익명 클래스**에 비해 **보일러플레이트 코드가 줄어들고, 가독성이 크게 향상**됩니다.
- **익명 클래스**는 여전히 **복수의 메서드를 오버라이드**하거나, **상태를 관리**해야 하는 경우 유용하지만, 가능한 경우에는 **람다를 사용하는 것이 더 간결하고 효율적**입니다.
- **타입 추론** 및 **로컬 변수 캡처** 같은 기능은 람다 표현식이 더 직관적이고 효율적인 코드 작성을 가능하게 합니다.

**결론적으로**, **함수형 인터페이스를 구현할 때는 익명 클래스 대신 람다 표현식을 사용하는 것이 더 좋습니다**. 람다는 **간결성**, **가독성**, **유지보수성** 측면에서 뛰어난 장점을 제공하므로, 자바 8 이후에는 가능한 **람다를 사용하는 것이 권장**됩니다.